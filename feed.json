{
    "version": "https://jsonfeed.org/version/1",
    "title": "hero的博客",
    "subtitle": "",
    "icon": "http://example.com/images/favicon.ico",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/12/08/%E8%8B%B1%E8%AF%AD/",
            "url": "http://example.com/2021/12/08/%E8%8B%B1%E8%AF%AD/",
            "title": "英语",
            "date_published": "2021-12-08T00:19:02.000Z",
            "content_html": "<p>resume 简历</p>\n<p>hire  租用，招聘</p>\n<p>insure 确保，投保</p>\n<p>insurance 保险</p>\n<p>community of scholar 学术团体</p>\n<p>consequence 结果</p>\n<p>admit 允许... 加入，承认</p>\n<p>marked 明显的</p>\n<p>arrangement 筹备</p>\n<p>norm 准则</p>\n<p>administration 管理</p>\n<p>peculiar 特殊的</p>\n<p>stability 稳定</p>\n<p>innovation 创新</p>\n<p>manifest 显现，使注意到</p>\n<p>institution 机构</p>\n<p>proportion 比例</p>\n<p>entry 进入</p>\n<p>watershed 转折点，分水岭</p>\n<p>arise 由... 引起</p>\n<p>unevenly 不均衡地</p>\n<p>contract 合同</p>\n<p>access 进入，获取，通道通路</p>\n<p>optimize 优化</p>\n<p>premium 保险费</p>\n<p>revenue 收入</p>\n<p>market 集市，营销</p>\n<p>outprefrom 超过</p>\n<p>bias 偏心  biased</p>\n<p>unconscious 无意识的</p>\n<p>experiment 实验</p>\n<p>guilty 有罪的</p>\n<p>render  宣布</p>\n<p>roast 烤肉  toast 烤</p>\n<p>nonetheless 然鹅</p>\n<p>towards 接近（某时刻）</p>\n<p>till 直到</p>\n<p>match 相匹敌</p>\n<p>patience 耐心，坚忍</p>\n<p>concern 关心</p>\n<p>intensified 加强的</p>\n<p>privileged 有特权的</p>\n<p>compell 强迫</p>\n<p>while 尽管   Since 既然，由于</p>\n<p>advisable 明智的</p>\n<p>urgent 紧急的</p>\n<p>forunate 幸运的</p>\n<p>in constrast to 与... 形成对比</p>\n<p>in particular 尤其</p>\n<p>after all 毕竟，终究</p>\n<p>principle 原理，原则</p>\n<p>to be brief 简言之</p>\n<p>reluctantly 不情愿的</p>\n<p>entirely 完全的</p>\n<p>gradually 渐渐的</p>\n<p>cut out 戒除</p>\n<p>came across 给人以... 印象</p>\n<p>scar 惊吓</p>\n<p>pushy 强势的，急于求成的</p>\n<hr>\n<p>institue 建立</p>\n<p>confine 限定，限制</p>\n<p>bid  尝试</p>\n<p>an avalanche of\t突然大量到来的某物</p>\n<p>lack  缺乏</p>\n<p>consolidate  加强</p>\n<p>prestigous 有声望的</p>\n<p>bag 抢占</p>\n<p>cynic 悲观者，怀疑者</p>\n<p>speculate 推测</p>\n<p>desperation 极度渴望</p>\n<p>booby prize  安慰奖</p>\n<p>on the verge of  濒于.....</p>\n<p>spell 持续的一段时间</p>\n<p>press 新闻界</p>\n<p>aspritaion  愿景</p>\n<p>a contrasting case  反例  contrasting 对比</p>\n<p>peculiarities  特色</p>\n<p>celebrate  赞美</p>\n<p>Skeptical  质疑</p>\n<p>Objective 客观  Subjective</p>\n<p>pessimism 悲观 optimistic</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/12/01/%E6%96%B0%E5%A2%9E%E8%80%83%E7%82%B9/",
            "url": "http://example.com/2021/12/01/%E6%96%B0%E5%A2%9E%E8%80%83%E7%82%B9/",
            "title": "新增考点",
            "date_published": "2021-12-01T10:36:38.000Z",
            "content_html": "<h1 id=\"机组\"><a class=\"anchor\" href=\"#机组\">#</a> 机组</h1>\n<h2 id=\"多处理器\"><a class=\"anchor\" href=\"#多处理器\">#</a> 多处理器</h2>\n<h4 id=\"sisd单指令流单数据流\"><a class=\"anchor\" href=\"#sisd单指令流单数据流\">#</a> SISD (单指令流单数据流)</h4>\n<p>一段时间内仅执行一条指令，有些采用流水线方式，设置多个功能部件，并采用多模块交叉方式</p>\n<h4 id=\"simd单指令多数据流\"><a class=\"anchor\" href=\"#simd单指令多数据流\">#</a> SIMD 单指令多数据流</h4>\n<p>一个指令控制部件，多个处理单元，每个单元有自己的地址寄存器，所有有不同的数据地址，因此，不同处理单元执行同一条指令所处理的数据时不同的</p>\n<p>在使用 for 循处理数组最有效，在使用 case 或 switch 时效率最低</p>\n<h4 id=\"misd多指令单流水不存在\"><a class=\"anchor\" href=\"#misd多指令单流水不存在\">#</a> MISD 多指令单流水（不存在）</h4>\n<h4 id=\"mimd多指令多数据流\"><a class=\"anchor\" href=\"#mimd多指令多数据流\">#</a> MIMD 多指令多数据流</h4>\n<p>每个计算机节点都有字节的私有存储器，具有独立的主存地址空间，不能够通过存取指令来访问不同节点的私有存储器，而是通过消息传递进行数据传送，也称为消息传递 MIMD</p>\n<p><strong>多处理器系统时共享存储多处理器 SMP 的简称</strong></p>\n<h4 id=\"向量处理器时simd的变种\"><a class=\"anchor\" href=\"#向量处理器时simd的变种\">#</a> 向量处理器时 SIMD 的变种</h4>\n<p>实现了直接操作一维数组指令集的 cpu，在数值模拟和相似领域性能极高</p>\n<h2 id=\"硬件多线程的基本概念\"><a class=\"anchor\" href=\"#硬件多线程的基本概念\">#</a> 硬件多线程的基本概念</h2>\n<p>在支持硬件多线程的 cpu 中，必须为每个线程提供单独的通用寄存器和程序计数器</p>\n<h3 id=\"细粒度多线程\"><a class=\"anchor\" href=\"#细粒度多线程\">#</a> 细粒度多线程</h3>\n<h3 id=\"粗粒度多线程\"><a class=\"anchor\" href=\"#粗粒度多线程\">#</a> 粗粒度多线程</h3>\n<p>尽在一个线程出现较大开销的阻塞时才切换进程，如 Cache 缺失，新线程的开销比细粒度多</p>\n<h3 id=\"同时多线程intel处理器\"><a class=\"anchor\" href=\"#同时多线程intel处理器\">#</a> 同时多线程（Intel 处理器）</h3>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211201192640838.png\" alt=\"image-20211201192640838\"></p>\n<h2 id=\"多核处理器的基本概念\"><a class=\"anchor\" href=\"#多核处理器的基本概念\">#</a> 多核处理器的基本概念</h2>\n<p>每个核可以有独自的 Cache，也可以共享同一 Cache</p>\n<h2 id=\"共享内存多处理器smp\"><a class=\"anchor\" href=\"#共享内存多处理器smp\">#</a> 共享内存多处理器 SMP</h2>\n<p>共享同一物理地址空间，但仍然可以有自己的虚拟地址空间</p>\n<p><strong>统一存储器访问 UMA</strong>：每个处理器访问存储单元的时间大致相同，即访问时间于哪个处理器提出访存请求及访问哪个字无关。（分为，基于总线，基于交叉开关网络，基于多级交换网络连接等处理器）</p>\n<p><strong>非统一存储访问 NUMA</strong>：不带告诉缓存 - NC-NUMA，否则 CC-NUMA</p>\n<h2 id=\"总线事务和定时\"><a class=\"anchor\" href=\"#总线事务和定时\">#</a> 总线事务和定时</h2>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/7TLHdp5rq7giaDPgLks3icxSmFibODwLoKmz3QR1oZlXHibxwdIkZ97R4XBTPOot7gFRiaInnEmbq9V7FoNcoxPW9bg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<h2 id=\"固态硬盘\"><a class=\"anchor\" href=\"#固态硬盘\">#</a> 固态硬盘</h2>\n<p>基于闪存技术的存储器，和 U 盘没有本质差别。由多个闪存芯片和闪存翻译层组成</p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211201204531891.png\" alt=\"image-20211201204531891\"></p>\n<p>只有在一页所属的整个块被擦除后才能写着一页。</p>\n<p>随机写很慢，随机访问比机械磁盘快，易磨损</p>\n<h2 id=\"程序的机器级表示\"><a class=\"anchor\" href=\"#程序的机器级表示\">#</a> 程序的机器级表示</h2>\n<h1 id=\"操作系统\"><a class=\"anchor\" href=\"#操作系统\">#</a> 操作系统</h1>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211204210513357.png\" alt=\"image-20211204210513357\"></p>\n<h3 id=\"操作系统结构\"><a class=\"anchor\" href=\"#操作系统结构\">#</a> 操作系统结构</h3>\n<h4 id=\"分层法\"><a class=\"anchor\" href=\"#分层法\">#</a> 分层法</h4>\n<p>第 0 层是硬件，第 N 层是用户接口</p>\n<p>便于调式和验证，容易扩充和维护</p>\n<p>不灵活，系统效率低下</p>\n<h4 id=\"模块化\"><a class=\"anchor\" href=\"#模块化\">#</a> 模块化</h4>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211204210946939.png\" alt=\"image-20211204210946939\"></p>\n<h4 id=\"宏内核\"><a class=\"anchor\" href=\"#宏内核\">#</a> 宏内核</h4>\n<p>现在主流的操作系统都是宏内核</p>\n<h4 id=\"微内核\"><a class=\"anchor\" href=\"#微内核\">#</a> 微内核</h4>\n<p>主要解决操作系统内核代码难以维护的问题</p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211204211620389.png\" alt=\"image-20211204211620389\"></p>\n<p>一个模块的错误只会使这个模块奔溃，不会使整个系统崩溃，宏内核反之</p>\n<p><strong>优点</strong>：扩展性和灵活性，可靠性和安全性，可移植性，分布式计算</p>\n<p><strong>缺点</strong>：频繁切换和心态和用户态，系统开销大</p>\n<h4 id=\"外核\"><a class=\"anchor\" href=\"#外核\">#</a> 外核</h4>\n<p>减少映射层，不用维护表格来重映像磁盘地址</p>\n<h3 id=\"操作系统引导\"><a class=\"anchor\" href=\"#操作系统引导\">#</a> 操作系统引导</h3>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211204212311229.png\" alt=\"image-20211204212311229\"></p>\n",
            "tags": [
                "新增考点"
            ]
        },
        {
            "id": "http://example.com/2021/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%8F%99/",
            "url": "http://example.com/2021/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%8F%99/",
            "title": "计算机系统概叙",
            "date_published": "2021-11-24T07:26:46.000Z",
            "content_html": "",
            "tags": [
                "考研",
                "计算机组成原理"
            ]
        },
        {
            "id": "http://example.com/2021/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/",
            "url": "http://example.com/2021/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/",
            "title": "数据结构需要注意的点",
            "date_published": "2021-11-19T06:30:36.000Z",
            "content_html": "<h1 id=\"绪论\"><a class=\"anchor\" href=\"#绪论\">#</a> 绪论</h1>\n<h2 id=\"基本概念和术语\"><a class=\"anchor\" href=\"#基本概念和术语\">#</a> 基本概念和术语</h2>\n<h3 id=\"数据\"><a class=\"anchor\" href=\"#数据\">#</a> 数据</h3>\n<p>​    数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序是被和处理的符号的集合。</p>\n<h3 id=\"数据元素\"><a class=\"anchor\" href=\"#数据元素\">#</a> 数据元素</h3>\n<p>​     数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个人的话剧遇上年度可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。</p>\n<h3 id=\"数据对象\"><a class=\"anchor\" href=\"#数据对象\">#</a> 数据对象</h3>\n<p>​     数据对象是具有相同性质的数据元素的集合，是数据的一个子集。</p>\n<h3 id=\"数据类型\"><a class=\"anchor\" href=\"#数据类型\">#</a> 数据类型</h3>\n<p>​     数据类型是一个值的集合和定义在此集合上的一组操作的总称。<br>\n​     1）原子类型：其值不可再分的数据类型。<br>\n​     2) 结构类型：其值可以再分解为若干成分的数据类型。<br>\n​     3）抽象数据类型：抽象数据组织与之相关的操作。</p>\n<h3 id=\"数据结构\"><a class=\"anchor\" href=\"#数据结构\">#</a> 数据结构</h3>\n<p>​     数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中数据元素都不是孤立的，它们之间存在着某种关系，这种数据元素相互之间的关系成为结构。数据结构包括三方面的内容：逻辑结构，存储结构和数据的运算。<br>\n​     一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</p>\n<h2 id=\"数据结构三要素\"><a class=\"anchor\" href=\"#数据结构三要素\">#</a> 数据结构三要素</h2>\n<h3 id=\"数据的逻辑结构\"><a class=\"anchor\" href=\"#数据的逻辑结构\">#</a> 数据的逻辑结构</h3>\n<p>​     逻辑结构是指数据元素之间的逻辑关系，从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210329104558981.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTgzMDEw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<pre><code> 集合：结构中的数据元素除同属于一个集合之外，没有别的关系。\n 线性结构：结构中的数据元素之间只存在一对一的关系。\n 树形结构：结构中的数据元素之间存在一对多的关系。\n 图状结构或网状结构：结构中的数据元素之间存在多对多的关系。\n</code></pre>\n<h3 id=\"数据的存储结构\"><a class=\"anchor\" href=\"#数据的存储结构\">#</a> 数据的存储结构</h3>\n<p>​     存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构，他包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言，数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。<br>\n​     1）顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间。缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。<br>\n​     2）链式存储。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用存储空间，缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。<br>\n​     3) 索引存储。在存储元素信息的同时还建立了附加的索引表，索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。其优点是检索速度快，缺点是附加的索引表额外占用存储空间，修改索引表也花费较多的时间。<br>\n​     4) 散列存储。根据元素的关键字直接计算出该元素的存储地址，又称哈希存储，其优点是检索，增加和删除节点的操作都很快，缺点是若散列函数不好，可能会出现冲突。</p>\n<h3 id=\"数据的运算\"><a class=\"anchor\" href=\"#数据的运算\">#</a> 数据的运算</h3>\n<p>​     施加在数据上的运算包括运算的定义和实现，运算的定义是针对逻辑结构的，指出运算的功能，运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>\n<h2 id=\"算法的基本概念\"><a class=\"anchor\" href=\"#算法的基本概念\">#</a> 算法的基本概念</h2>\n<p>​     算法是对特定问题求解步骤的一种描述，它是指令的序列，其中的每条指令表示一个或多个操作。而且算法还有以下 5 个重要特性。<br>\n​     有穷性：一个算法必须执行有穷步之后结束，且每一步都可在有穷时间内完成。<br>\n​     确定性：算法中每条指令都必须有确切的含义，对于相同的水只能得出相同的输出。<br>\n​     可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。<br>\n​     输入：一个算法有零个或多个输入，这些输入取自某个特定的对象的集合。<br>\n​     输出：一个算法有一个或多个输出，这些输出是与输入有某种特定关系的量。<br>\n​     通常一个优秀算法应考虑一下目标：<br>\n​     正确性：算法应能够正确解决问题。<br>\n​     可读性：算法应具有良好的可读性，以便人民理解。<br>\n​     效率与低存储量需求：效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。</p>\n<p>![image-20211119151040856]image-20211119151040856.png)</p>\n<h1 id=\"线性表\"><a class=\"anchor\" href=\"#线性表\">#</a> 线性表</h1>\n<p>线性表的顺序存储结构是一种<strong>随机存取（读写）<strong>的存储结构，不是顺序存取的存储结构，是</strong>顺序存储</strong>的村树结构</p>\n<p><img data-src=\"image-20211119151605513.png\" alt=\"image-20211119151605513\"></p>\n<p>即使带头尾指针，循环单链表页<strong>不好删除最后一个节点</strong></p>\n<h1 id=\"栈和队列\"><a class=\"anchor\" href=\"#栈和队列\">#</a> 栈和队列</h1>\n<p>n 个不同元素进栈，出栈可能为</p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211119152212184.png\" alt=\"image-20211119152212184\"></p>\n<p>在用单链表实现队列时，<strong>队头设在链表的表头位置</strong>（存疑，王道这么说的）</p>\n<h2 id=\"栈在表达式中求值的应用\"><a class=\"anchor\" href=\"#栈在表达式中求值的应用\">#</a> 栈在表达式中求值的应用</h2>\n<p><strong>中缀表达式</strong>：A+B*（C-D）-E/F</p>\n<p><strong>后缀表达式</strong>：ABCD-*+EF/-</p>\n<p><strong>中缀转后缀</strong>：</p>\n<p>​\t1. 直接做题可以构造树，并后序遍历就是后缀表示了</p>\n<p>​\t2. 用两个栈，并设置符号优先级</p>\n<p><span class=\"rainbow\">执行函数时，局部变量一般采用栈结构</span></p>\n<h2 id=\"特殊矩阵压缩存储\"><a class=\"anchor\" href=\"#特殊矩阵压缩存储\">#</a> 特殊矩阵压缩存储</h2>\n<p>原矩阵下标从 1 开始，目的矩阵下标从 0 开始</p>\n<h3 id=\"对称矩阵可以直接用三角矩阵包括\"><a class=\"anchor\" href=\"#对称矩阵可以直接用三角矩阵包括\">#</a> 对称矩阵 (可以直接用三角矩阵包括)</h3>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>i</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">(</mo><mi>i</mi><mo>&gt;</mo><mo>=</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">i(i-1)/2+j-1 (i&gt;=j)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>j</mi><mo stretchy=\"false\">(</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo>+</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">(</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">j(j-1)/2+i-1(i&lt;j)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<h3 id=\"三角矩阵\"><a class=\"anchor\" href=\"#三角矩阵\">#</a> 三角矩阵</h3>\n<p><strong>下三角按行</strong></p>\n<h3 id><a class=\"anchor\" href=\"#\">#</a> </h3>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>i</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo>+</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">(</mo><mi>i</mi><mo>&gt;</mo><mo>=</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">i(i-1)/2+j-1(i&gt;=j)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">(</mo><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(n+1)/2(i&lt;j)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><strong>上三角按行</strong></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mn>2</mn><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mo stretchy=\"false\">(</mo><mi>j</mi><mo>−</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mi>i</mi><mo>&lt;</mo><mo>=</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(i-1)(2n-i+2)+(j-i)(i&lt;=j)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>n</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo stretchy=\"false\">(</mo><mi>i</mi><mo>&gt;</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">n(n+1)/2(i&gt;j)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<h2 id=\"三对称矩阵\"><a class=\"anchor\" href=\"#三对称矩阵\">#</a> 三对称矩阵</h2>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>k</mi><mo>=</mo><mn>2</mn><mi>i</mi><mo>+</mo><mi>j</mi><mo>−</mo><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">k=2i+j-3\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span></span></span></span></span></p>\n<h1 id=\"串\"><a class=\"anchor\" href=\"#串\">#</a> 串</h1>\n<h2 id=\"串的存储结构\"><a class=\"anchor\" href=\"#串的存储结构\">#</a> 串的存储结构</h2>\n<p><strong>定长顺序存储</strong></p>\n<p><strong>堆分配存储表示</strong>：c 语言中存在一个称为堆的自由存储区</p>\n<p><strong>块链存储表示</strong></p>\n<h2 id=\"kmp算法\"><a class=\"anchor\" href=\"#kmp算法\">#</a> KMP 算法</h2>\n<p><strong>kmp 的进一步优化</strong>：忘记了感觉以下这个例子：主串（abaabaabca）子串（abaabc）</p>\n<p>忘记了就做几道题压压惊</p>\n<p><img data-src=\"image-20211119205311817.png\" alt=\"image-20211119205311817\"></p>\n<h1 id=\"树与二叉树\"><a class=\"anchor\" href=\"#树与二叉树\">#</a> 树与二叉树</h1>\n<p>树的路径长度时从树根道每个节点的路径长度的总和</p>\n<p>非空二叉树的叶子节点数等于度为 2 的节点数 + 1</p>\n<p>度为 2 的有序树不是二叉树</p>\n<h2 id=\"线索二叉树\"><a class=\"anchor\" href=\"#线索二叉树\">#</a> 线索二叉树</h2>\n<h3 id=\"建立线索2叉树\"><a class=\"anchor\" href=\"#建立线索2叉树\">#</a> 建立线索 2 叉树</h3>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">InThread</span><span class=\"token punctuation\">(</span>ThreadTree <span class=\"token operator\">&amp;</span>p，ThreadTree <span class=\"token operator\">&amp;</span>pre<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">!</span> <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t<span class=\"token function\">inrhread</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">-></span> lchild<span class=\"token punctuation\">,</span>pre<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>lchild <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\t\t\tp<span class=\"token operator\">-></span>lchild <span class=\"token operator\">=</span> pre<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t\t\tp<span class=\"token operator\">-></span>ltag <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>\t\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>pre<span class=\"token operator\">!=</span><span class=\"token constant\">NULL</span> <span class=\"token operator\">&amp;</span>z<span class=\"token operator\">&amp;</span> pre<span class=\"token operator\">-></span>rchild<span class=\"token operator\">==</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t\t\tpre<span class=\"token operator\">-></span>rchild <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t\t\tpre<span class=\"token operator\">-></span>rtag <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\t\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t\tpre <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>\t</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>\t\t<span class=\"token function\">InThread</span><span class=\"token punctuation\">(</span>p<span class=\"token operator\">-></span>rchild<span class=\"token punctuation\">,</span> pre<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>\t<span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p><span class=\"rainbow\">森林可以 0 棵树   </span></p>\n<p><strong>后序线索二叉树不能有效解决寻找后继</strong></p>\n<p><strong>先序线索二叉树不能有效解决寻找前驱</strong>（需要栈的支持）</p>\n<p><strong>后序树不能完整遍历</strong>（需要栈的支持）</p>\n<p><strong>树的先根遍历</strong>与<strong>二叉树的先序遍历</strong>一样，<strong>森林先序</strong></p>\n<p>树的后根遍历与二叉树的中序遍历一样，<strong>森林中序</strong></p>\n<h2 id=\"平衡二叉树\"><a class=\"anchor\" href=\"#平衡二叉树\">#</a> 平衡二叉树</h2>\n<p>结点个数最少的平衡二叉树，h 为高度:n (h)=n (h-1)+n (h-2)+1</p>\n<h2 id=\"哈夫曼树\"><a class=\"anchor\" href=\"#哈夫曼树\">#</a> 哈夫曼树</h2>\n<p><strong>WPL</strong> 带权路径长度</p>\n<h1 id=\"图\"><a class=\"anchor\" href=\"#图\">#</a> 图</h1>\n<p><span class=\"rainbow\">线性表可以是空表，树可以是空树，但图不可以是空图</span></p>\n<p>联通分量就是极大联通子图</p>\n<p>带权图邻接矩阵，<strong>0 和无穷都是无边的意思</strong></p>\n<p><span class=\"rainbow\">有公共子式的表达式，可以用有向无环图来表示，减少空间消耗</span></p>\n<p><strong>DAG 有向无环图，AOV 拓扑排序网</strong></p>\n<hr>\n<p><span class=\"rainbow\">只要无向连通图中没有权值相同的边，则最小生成树唯一，充分条件</span></p>\n<p><span class=\"rainbow\">只要图中每个顶点的入度出度都为 1，则拓扑序列唯一，充分条件</span></p>\n<h1 id=\"查找\"><a class=\"anchor\" href=\"#查找\">#</a> 查找</h1>\n<p><strong>ASL</strong>：平均查找长度</p>\n<h3 id=\"有序表查找\"><a class=\"anchor\" href=\"#有序表查找\">#</a> 有序表查找</h3>\n<p><img data-src=\"https://img-blog.csdnimg.cn/2019091716052376.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpX2plcmVteQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>查找失败 ASL= n/2+n/(n+1)。</p>\n<h3 id=\"折半查找法\"><a class=\"anchor\" href=\"#折半查找法\">#</a> 折半查找法</h3>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190917163215574.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpX2plcmVteQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>\n是平衡二叉树</p>\n<h3 id=\"分块查找\"><a class=\"anchor\" href=\"#分块查找\">#</a> 分块查找</h3>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190917164110259.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpX2plcmVteQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>若在块内和索引表中均采用顺序查找，则平均查找长度为 (s・s+2・s+n)/2・s</p>\n<h2 id=\"b树\"><a class=\"anchor\" href=\"#b树\">#</a> B 树</h2>\n<p>1. 若根结点不是终端结点，则至少有 2 棵子树。<br>\n2. 除根节点以外的所有非叶结点至少有 M/2 **（向上取整）** 棵子树，至多有 M 个子树（关键字数为 M-1）。<br>\n3. 所有的叶子结点都位于同一层。</p>\n<h4 id=\"b树的插入和删除\"><a class=\"anchor\" href=\"#b树的插入和删除\">#</a> B 树的插入和删除</h4>\n<p><img data-src=\"image-20211123201303622.png\" alt=\"image-20211123201303622\"></p>\n<p><img data-src=\"image-20211123201320269.png\" alt=\"image-20211123201320269\"></p>\n<p><img data-src=\"image-20211123201335181.png\" alt=\"image-20211123201335181\"></p>\n<p><img data-src=\"image-20211123201347019.png\" alt=\"image-20211123201347019\"></p>\n<p><img data-src=\"image-20211123201401855.png\" alt=\"image-20211123201401855\"></p>\n<h3 id=\"b树-2\"><a class=\"anchor\" href=\"#b树-2\">#</a> B + 树</h3>\n<p>节点的子树数和关键字数相同（B 树是关键字数比子树数少一）<br>\n节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据<br>\n叶子节点包含了全部数据，同时符合左小右大的顺序</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190917174242843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpX2plcmVteQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p><strong>三个特点</strong></p>\n<p>关键字数和子树相同<br>\n非叶子节点仅用作索引，它的关键字和子节点有重复元素<br>\n叶子节点用指针连在一起</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190917174347747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpX2plcmVteQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p><span class=\"rainbow\">B 树和 B + 树支持随机查找</span></p>\n<p><span class=\"rainbow\">B 树不支持顺序查找和 B + 树支持顺序查找</span></p>\n<h2 id=\"散列表\"><a class=\"anchor\" href=\"#散列表\">#</a> 散列表</h2>\n<p>散列表建立了关键字和存储地址之间的一种直接映射关系</p>\n<p><strong>常用的散列函数：</strong></p>\n<p>直接定址法</p>\n<p>除留余数法</p>\n<p>数字分析法：H（key）=key%100000</p>\n<p>平房取中法：比如 key=1234 1234^2=1522756 取 227 作 hash 地址<br>\n<strong>冲突处理</strong></p>\n<p>平方探测可避免堆积（<strong>由同义词之间或非同义词之间发生冲突</strong>）</p>\n<p>** 再散列法：** 需要使用两个散列函数，当通过第一个散列函数时 H (key) 得到的地址发生冲突时，则利用第二个散列函数 Hash2 (key) 计算该关键字的地址增量，具体散列函数如下：Hi = (H (key)+iHash2 (key))% m。<br>\n初次探测位置 H0 = H (key)% m。i 是冲突次数，初始为 0。<strong>在散列法中，最多经过 m-1 次探测就会遍历表中的所有位置，回到 H0 位置</strong>。</p>\n<p>装载因子 α=n/m (n 表示实际装载数据长度 m 为表长)</p>\n<p><span class=\"rainbow\">平均查找长度依赖于装填因子，不直接依赖于 n 或 m</span></p>\n<p><img data-src=\"image-20211123204437738.png\" alt=\"image-20211123204437738\"></p>\n<p><strong>注意平均查找长度，和表长无直接关系</strong></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190917194129346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpX2plcmVteQ==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"排序\"><a class=\"anchor\" href=\"#排序\">#</a> 排序</h1>\n<p>拓扑排序不算在排序算法内</p>\n<p><strong>希尔排序（缩小增量排序）</strong></p>\n<p>n 在某个特定范围时，时间复杂度约为 n^1.3</p>\n<p><img data-src=\"https://upload-images.jianshu.io/upload_images/1156494-62f859c2ac6f95ff.png\" alt=\"img\"></p>\n<p><strong>快速排序</strong>是所有排序算法中品军性能最优的</p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211124103643158.png\" alt=\"image-20211124103643158\"></p>\n<h3 id=\"外部排序\"><a class=\"anchor\" href=\"#外部排序\">#</a> 外部排序</h3>\n<p><img data-src=\"image-20211124125859446.png\" alt=\"image-20211124125859446\"></p>\n<p><img data-src=\"image-20211124125916059.png\" alt=\"image-20211124125916059\"></p>\n<p><img data-src=\"image-20211124125931356.png\" alt=\"image-20211124125931356\"></p>\n",
            "tags": [
                "考研",
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2021/11/17/%E5%BA%94%E7%94%A8%E5%B1%82/",
            "url": "http://example.com/2021/11/17/%E5%BA%94%E7%94%A8%E5%B1%82/",
            "title": "应用层",
            "date_published": "2021-11-17T02:23:14.000Z",
            "content_html": "<h1 id=\"网络应用模型\"><a class=\"anchor\" href=\"#网络应用模型\">#</a> 网络应用模型</h1>\n<h2 id=\"客户服务器模型\"><a class=\"anchor\" href=\"#客户服务器模型\">#</a> 客户 / 服务器模型</h2>\n<p>在 C/S 模型中，客户是服务请求方，服务器是服务提供方。网络中各计算机的<strong>地位不平等</strong>，服务器可以通过对用户权限的限制来达到管理客户机的目的，使它们不能随意存储／删除数据，或进行其他受限的网络活动。而客户机相互之间不直接进行通信，可扩展性不佳。</p>\n<p><span class=\"rainbow\">客户端面向用户，服务器面向任务</span></p>\n<h3 id=\"cs模型主要应用\"><a class=\"anchor\" href=\"#cs模型主要应用\">#</a> C/S 模型主要应用</h3>\n<p>客户 / 服务器模型的应用：Web、文件传输协议（FTP）、远程登录和电子邮件。</p>\n<h2 id=\"p2p模型\"><a class=\"anchor\" href=\"#p2p模型\">#</a> P2P 模型</h2>\n<h3 id=\"p2p模型概述\"><a class=\"anchor\" href=\"#p2p模型概述\">#</a> P2P 模型概述</h3>\n<p>在 P2P 模型中，各计算机没有固定的客户和服务器划分，任意一对计算机 —— 称为 ** 对等方 **(Peer)，<strong>直接相互通信</strong>。每个结点既作为客户访问其他结点的资源，也作为服务器提供资源给其他结点访问。P2P 的应用：PPlive、Bittorrent 和电驴。</p>\n<h3 id=\"p2p模型的优缺点\"><a class=\"anchor\" href=\"#p2p模型的优缺点\">#</a> P2P 模型的优缺点</h3>\n<p>​\tP2P 模型的优点：减轻了服务器的计算压力，消除了对某个服务器的完全依赖，提高了系统效率和资源利用率。多个客户机之间可以直接共享文档，可扩展性好，网络健壮性强，单个结点的失效不会影响其他部分的结点。<br>\n​    P2P 模型的缺点：占用较多的内存影响整机速度，P2P 下载会对硬盘造成较大的损伤，是网络变得非常拥堵。因此，各大 isp（互联网服务提供商，如电信网通等）通常都对 P2P 应用持反对态度。</p>\n<h1 id=\"域名系统dns\"><a class=\"anchor\" href=\"#域名系统dns\">#</a> 域名系统（DNS）</h1>\n<p><span class=\"ranbow\">Internet 上提供客户访问的主机不一定要有域名，多个域名可以指向同一台主机（主机有多个 IP 地址，在不同网段），一个域名可以指向多个主机（为了负载均衡）</span></p>\n<p>域名系统 (DNS) 是因特网使用的命名系统， 用来把便于人们记忆的具有特定含义的主机名（如 www.cskaoya <span class=\"exturl\" data-url=\"aHR0cDovL24uY29t\">n.com</span>) 转换为便于机器处理的 IP 地址，<strong>DNS 系统采用 客户／服务器模型，协议运行在 UDP 之上，使用 53 号端口</strong>。</p>\n<h3 id=\"域名规则\"><a class=\"anchor\" href=\"#域名规则\">#</a> 域名规则</h3>\n<p>（1）<strong>标号中的英文不区分大小写</strong>。<br>\n（2）标号中除连字符（－）外不能使用其他的标点符号。<br>\n（3）每个标号不超过 63 个字符，多标号组成的完整域名最长不超过 255 个字符。<br>\n（4）级别最低的域名写在最左边，级别最高的顶级域名写在最右边。</p>\n<h3 id=\"顶级域名分类\"><a class=\"anchor\" href=\"#顶级域名分类\">#</a> 顶级域名分类</h3>\n<p>国家顶级域名 (nTLD)：国家和某些地区的域名， 如 “.cn &quot;表示中 国， ＂．us&quot; 表示美国， ＂．uk&quot; 表示英国 。<br>\n顶级域名分类 通用顶级域名 (gTLD)：常见的有 “.com” （公司）、 “.net”（网络服务机构）、 “org”（非营利性组织）和 “.gov”（国家 或政府部门）等。<br>\n基础结构域名：这种顶级域名只有一个 arpa，用于反向域名解析，因此又称反向域名。</p>\n<h2 id=\"域名服务器\"><a class=\"anchor\" href=\"#域名服务器\">#</a> 域名服务器</h2>\n<p>因特网的域名系统被设计成一个联机分布式的数据库系统，并采用<strong>客户／服务器模型</strong>。<br>\n<strong>根域名服务器</strong>：是最高层次的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的 IP 地址。<br>\n<strong>顶级域名服务器</strong>：负责管理在该顶级域名服务器注册的所有二级域名，收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当查找的域名服务器的 IP 地址）。<br>\n<strong>授权域名服务器</strong>（权限域名服务器）：每台主机都必须在授权域名服务器处登记，授权域名服务器总能将其管辖的主机名转换为该主机的 IP 地址。<br>\n<strong>本地域名服务器</strong>：当一台主机发出 DNS 查询请求时 ，这个查询请求报文 就发送给该主机的本地域名服务器，每个因特网服务提供者 (ISP)，或一所大学，甚至一 所大学中的各个系，都可以拥有一个本地域名服务器。</p>\n<h2 id=\"域名解析过程\"><a class=\"anchor\" href=\"#域名解析过程\">#</a> 域名解析过程</h2>\n<p>域名解析就是指把域名映射成为 IP 地址或把 IP 地址映射成域名的过程。前者称为正向解析。后者称为反向解析。域名解析有两种方式递归查询和递归与迭代相结合的查询。</p>\n<h3 id=\"查询方式\"><a class=\"anchor\" href=\"#查询方式\">#</a> 查询方式</h3>\n<p>递归查询：该方法给根域名服务造成的负载过大，所以在实际中几乎不使用。<br>\n归与迭代相结合的查询：主机向本地域名服务器的查询采用的是递归查询，本地域名服务器向根域名服务器的查询采用迭代查询。</p>\n<h3 id=\"域名解析过程-2\"><a class=\"anchor\" href=\"#域名解析过程-2\">#</a> 域名解析过程</h3>\n<p>客户机向其本地域名服务器发出 DNS 请求报文，本地域名服务器收到请求后，查询本地缓存，若没有该记录，则以 DNS 客户的身份向根域名服务器发出解析请求，根域名服务器收到请求后，判断该域名属于域，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1kbnMtNHcyZTE4ZG94ZjY0Yzh4bWxkMzAxYTA1emtuNmJ5ZHcxczZmLmNvbQ==\">将对应的顶级域名服务器 dns.com</span> 的 IP 地址返回给本地域名服务器，本地域名服务器向顶级域名服务器 dns.com 发出解析请求报文，顶级域名服务器 dns.com 收到请求后，判断该域名属于 abc.com 域，因此将对应的授权域名服务器 dns.abc.com 的 IP 地址返回给本地域名服务器，本地域名服务器向授权域名服务器 dns.abc.com 发起解析请求报文，授权域名服务器 dns.abc.com 收到请求后，将查询结果返回给本地域名服务器，本地域名服务器将查询结果保存到本地缓存，同时返回给客户机。<br>\n为了提高 DNS 的查询效率，减少因特网上的 DNS 查询报文数量，在域名服务器中广泛的使用了高速缓存，<strong>但是因为主机名和 IP 地址之间的映射不是永久的，所以 DNS 服务器将在一段时间后丢弃高速缓存中的信息</strong>。</p>\n<p><span class=\"rainbow\">域名解析过程可能会访问多个权限域名服务器（<span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5hYmMueHl6LmNvbQ==\">www.abc.xyz.com</span>，就需要访问两个权限域名服务器）</span></p>\n<h1 id=\"文件传输协议ftp\"><a class=\"anchor\" href=\"#文件传输协议ftp\">#</a> 文件传输协议（FTP）</h1>\n<p><span class=\"rainbow\">控制信息使外带传送的</span></p>\n<p><span class=\"rainbow\">FTP 不适合在两个计算机之间共享读写信息</span></p>\n<h2 id=\"ftp的工作原理\"><a class=\"anchor\" href=\"#ftp的工作原理\">#</a> FTP 的工作原理</h2>\n<p>文件传输协议（FTP）是因特网上使用的最广泛的文件传输协议。FTP 提供交互式的访问，<strong>允许客户指明文件的类型与格式，并允许文件具有存取权限</strong>，它屏蔽了各计算机系统的细节，因而适合于在异构网络中的任意计算机之间传送文件。<strong>FTP 采用客户／服务器的工作方式，它使用 TCP 可靠的传输服务</strong>。</p>\n<h3 id=\"ftp功能\"><a class=\"anchor\" href=\"#ftp功能\">#</a> FTP 功能</h3>\n<p>（1）<strong>提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力</strong>。<br>\n（2）以用户权限管理的方式提供用户对远程 FTP 服务器上的文件管理能力。<br>\n（3）以匿名 FTP 的方式提供公用文件共享的能力。</p>\n<h3 id=\"ftp工作步骤\"><a class=\"anchor\" href=\"#ftp工作步骤\">#</a> FTP 工作步骤</h3>\n<p>FTP 的服务进程由两大部分组成，一个是<strong>主进程</strong>负责接收新的请求，另外有若干<strong>从属进程</strong>负责处理单个请求。其工作步骤如下：<br>\n（1）打开熟知端口 21 （控制端口），使客户进程能够连接上。<br>\n（2）等待客户进程方连接请求。<br>\n（3）启动从属进程来处理客户进程发来的请求，进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止。<br>\n（4）回到等待状态，继续接收其他客户进程的请求。</p>\n<h2 id=\"控制连接与数据连接\"><a class=\"anchor\" href=\"#控制连接与数据连接\">#</a> 控制连接与数据连接</h2>\n<p>FTP 在工作时使用两个并行的 TCP 连接，一个是控制连接（端口号 21），一个是数据连接（端口号为 20）。使用两个不同的端口号可以使协议更加简单和更容易实现。</p>\n<h3 id=\"控制连接\"><a class=\"anchor\" href=\"#控制连接\">#</a> 控制连接</h3>\n<p>服务器监听 21 号端口，等待客户连接，建立在这个端口上的连接称为控制连接。控制连接（端口号 21) 控制连接用来传输控制信息（如连接请求、 传送请求等），并且控制信息都以 7 位 ASCII 格式传送。<strong>控制连接在整个会话期间一直保持打开状态</strong>。</p>\n<h3 id=\"数据连接\"><a class=\"anchor\" href=\"#数据连接\">#</a> 数据连接</h3>\n<p>服务器端的控制进程在接收到 FTP 客户发来的文件传输请求后就创建数据传送进程和数据连接。<strong>传送完毕后关闭数据传送连接，并结束运行</strong>。<br>\n数据连接有两种传输模式：主动模式 PORT（端口号 20，服务器到客户）和被动模式 PASV（端口号随机 &gt; 1024，客户到服务器）</p>\n<h1 id=\"电子邮件\"><a class=\"anchor\" href=\"#电子邮件\">#</a> 电子邮件</h1>\n<h2 id=\"电子邮件系统组成结构\"><a class=\"anchor\" href=\"#电子邮件系统组成结构\">#</a> 电子邮件系统组成结构</h2>\n<p>一个电子邮件系统应具有三个最主要的组成构件：<br>\n用户代理 (UA)：用户与电子邮件系统的接口。<br>\n邮件服务器：它的功能是发送和接收邮件，同时还要向发信人报告邮件发送情况。<br>\n邮件发送协议和读取协议：邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件。如<strong> SMTP 协议</strong>：邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件。<strong>POP3</strong>: 邮件读取协议用于用户代理从邮件服务器读取邮件。</p>\n<h2 id=\"电子邮件收发过程\"><a class=\"anchor\" href=\"#电子邮件收发过程\">#</a> 电子邮件收发过程</h2>\n<p>发信人调用用户代理来撰写和编辑要发送的邮件。用户代理用 SMTP 把邮件传送给发送方邮件服务器。</p>\n<p>发送方邮件服务器将邮件放入邮件缓存队列中，等待发送。</p>\n<p>运行在发送方邮件服务器的 SMTP 客户进程，发现邮件缓存中有待发送的邮件，就向运行在接收方邮件服务器的 SMTP 服务器进程发起建立 TCP 连接。</p>\n<p>TCP 连接建立后，SMTP 客户进程开始向远程 SMTP 服务器进程发送邮件。当所有待发送邮件发完后，SMTP 就关闭所建立的 TCP 连接。</p>\n<p>运行在接收方邮件服务器中的 SMTP 服务器进程收到邮件后，将邮件放入收信人的用户 邮箱，等待收信人在方便时进行读取，收信人打算收信时，调用用户代理，使用 POP3（或 IMAP) 协议将自己的邮件从接收方 邮件服务器的用户邮箱中取回（如果邮箱中有来信的话）。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210221093855288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTgzMDEw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"电子邮件格式与mime\"><a class=\"anchor\" href=\"#电子邮件格式与mime\">#</a> 电子邮件格式与 MIME</h2>\n<h3 id=\"电子邮件格式\"><a class=\"anchor\" href=\"#电子邮件格式\">#</a> 电子邮件格式</h3>\n<p>to 是必需的关键字，后面填入一个或多个收件人的电子邮件地址。<br>\nSubject 是可选关键字，是邮件的主题，反映了邮件的主要内容。<br>\nFrom 是必填的关键字，但它通常由邮件系统自动填入。</p>\n<p><span class=\"exturl\" data-url=\"bWFpbHRvOmFiY0Bjc2thb3lhbi5jb20=\">abc@cskaoyan.com</span>，收件人游戏名 @邮件服务器所在主机域名，在整个因特网上是唯一的</p>\n<h3 id=\"多用途网际邮件扩充mime\"><a class=\"anchor\" href=\"#多用途网际邮件扩充mime\">#</a> 多用途网际邮件扩充（MIME）</h3>\n<p>SMTP 只能传送一定长度的 ASCII 码，许多其他非英语国家的文字（如中文）就无法传送无法传送可执行文件及其他二进制对象。MIME 使得可以继续使用目前的格式，增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。</p>\n<p><strong>MIME 内容：</strong><br>\n（1）5 个新的邮件首部字段，包括 MIME 版本、类型。<br>\n（2）定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。<br>\n（3）定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</p>\n<h2 id=\"smtp和pop3\"><a class=\"anchor\" href=\"#smtp和pop3\">#</a> SMTP 和 POP3</h2>\n<h3 id=\"简单邮件传输协议smtp\"><a class=\"anchor\" href=\"#简单邮件传输协议smtp\">#</a> 简单邮件传输协议 (SMTP)</h3>\n<p>简单邮件传输协议 (SMTP) 是一种提供可靠且有效的电子邮件传输的协议，它控制两个相互通信的 SMTP 进程交换信息使用客户／服务器方式，发送邮件的 SMTP 进程是 SMTP 客户，而负责接收邮件的 SMTP 进程是 SMTP 服务器，SMTP 使用的是 TCP 连接，端口号为 25。</p>\n<p><strong>SMTP 通信分为以下三个阶段：</strong></p>\n<p>（1）<strong>连接建立</strong>：<br>\n发件人的邮件发送到发送方邮件服务器的邮件缓存中后，SMTP 客户就每隔一段时间对邮件缓存扫描一次。如果发现有邮件，就使用 SMTP 的熟知端口号 (25) 与接收方邮件服务器的 SMTP 服务器建立 TCP 连接，SMTP 不使用中间邮件服务器。TCP 连接总是在发送方和接收方这两个邮件服务器之间直接建立。<br>\n（2）<strong>邮件传送</strong>：连接建立后，就可开始传送邮件，邮件的传送从 MAIL 命令开始，MAIL 命令后面有发件人的地址，SMTP 服务器已准备好接收邮件，则回答 250 OK，接着 SMTP 客户端发送一个或多个 RCPT（收件人 recipient 的缩写）命令，RCPT 命令的作用 先弄清接收方系统是否己做好接收邮件的准备，然后才发送邮件，避免浪费通信资源。获得 OK 的回答后，客户端就使用 DATA 命令，表示要开始传输邮件的内容。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/2021022109425857.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>（3）<strong>连接释放</strong>：邮件发送完毕后，SMTP 客户应发送 QUIT 命令，SMTP 服务器返回的信息是 <strong>221（服务关闭）</strong>，表示 SMTP 同意释放 TCP 连接。</p>\n<p><strong>简单邮件传输协议 (SMTP) 的缺点：</strong><br>\n（1）SMTP 不能传送可执行文件或者其他二进制对象。<br>\n（2）<strong>SMTP 仅限于传送 7 位 ASCII 码，不能传送其他非英语国家的文字</strong>。<br>\n（3）SMTP 服务器会拒绝超过一定长度的邮件。</p>\n<h3 id=\"pop3\"><a class=\"anchor\" href=\"#pop3\">#</a> POP3</h3>\n<p><span class=\"rainbow\">也是基于 ASCII 码的，登录到服务器后，发送的密码不加秘</span></p>\n<p>邮局协议 (POP) 是 个非常简单但功能有限的邮件读取协议，现在使用的是它的第 3 个版本 POP3，当用户读取邮件时，用 户代理向邮件服务器发出请求，拉取用户邮箱中的邮件，使用客户／服务器的工作方式，POP3 在传输层使用 TCP，<strong>端口号为 110.POP3 有两个工作方式 “下载并保留” 和 “下载并删除”</strong>。</p>\n<h3 id=\"因特网报文存取协议imap\"><a class=\"anchor\" href=\"#因特网报文存取协议imap\">#</a> 因特网报文存取协议（IMAP）</h3>\n<p>IMAP 也是一个邮件接收协议，比 POP 复杂得多，<strong>它为用户提供了创建文件夹，在不同文件夹之间移动邮件及在远程文件夹中查询邮件的命令</strong>，为此 IMAP 服务器维护了会话用户的状态信息。<strong>IMAP 的另一特性是允许用户代理只获取报文的某些部分</strong>。</p>\n<h3 id=\"基于万维网的电子邮件\"><a class=\"anchor\" href=\"#基于万维网的电子邮件\">#</a> 基于万维网的电子邮件</h3>\n<p>基于万维网的电子邮件的特点是：用户浏览器与 Hotmail 或 Gmail 的邮件服务器之间的邮件发送或接收使用 HTTP。在不同邮件服务器之间传送邮件时使用 SMTP。</p>\n<h1 id=\"万维网\"><a class=\"anchor\" href=\"#万维网\">#</a> 万维网</h1>\n<p>万维网是一个分布式、联机式的信息存储空间。在这个空间中，有用的事物称为资源，并由一个全域 “统一资源定位符” (URL) 标识。这些资源通过超文本传输协议 (HTTP) 传送给使用者，而后者通过单击链接来获取资源。</p>\n<h3 id=\"万维网组成\"><a class=\"anchor\" href=\"#万维网组成\">#</a> 万维网组成</h3>\n<p><strong>统一资源定位符</strong>：负烹标识万维网上的各种文档，并使每个文档在整个万维网的范围内具有唯 — 的标识符 URL.<br>\n<strong> 超文本传输协议 (HTTP)</strong>：— 个应用层协议，它使用 TCP 连接进行可靠的传输，HTTP 是万维 mk 网客户程序和服务器程序之间交互所必须严格遵守的协议。<br>\n<strong>超文本标记语言 (HTML)</strong>：— 种文档结构的标记语言，它使用 — 些约定的标记对页面上 的各种信息 **（包括文字、 声音、 图像、 视频等）**、 格式进行描述。</p>\n<h3 id=\"万维网的工作流程\"><a class=\"anchor\" href=\"#万维网的工作流程\">#</a> 万维网的工作流程</h3>\n<p>Web 用户使用浏览器（指定 URL) 与 Web 服务器建立连接，并发送浏览请求 Web 服务器把 URL 转换为文件路径，并返回信息给 Web 浏览器，通信完成后关闭连接。</p>\n<h2 id=\"超文本传输协议http\"><a class=\"anchor\" href=\"#超文本传输协议http\">#</a> 超文本传输协议（HTTP）</h2>\n<h3 id=\"超文本传输协议概述\"><a class=\"anchor\" href=\"#超文本传输协议概述\">#</a> 超文本传输协议概述</h3>\n<p>HTTP 定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器。<strong>HTTP 是面向事务的应用层协议</strong>，它规定了在浏览器和服务器之间的请求和响应的格式与规则，是万维网上能够可孔地交换文件的至要基础。</p>\n<h3 id=\"http操作过程\"><a class=\"anchor\" href=\"#http操作过程\">#</a> HTTP 操作过程</h3>\n<p>每个万维网站点都有一个服务器进程，它不断地监听 TCP 的端口 80（默认），当监听到连接请求后便与浏览器建立连接，TCP 连接建立后，浏览器就向服务器发送请求获取某个 Web 页面 的 HTTP 请求，服务器收到 HTTP 请求后，将构建所请求 Web 页的必需信息，并通过 HTTP 响应返回给浏览器浏览器再将信息进行解释， 然后将 Web 页显示给用户，最后释放 TCP 连接。<br>\n<strong>用户单击鼠标后发生的时间顺序</strong>：<br>\n浏览器分析链接指向页面的 URL 。浏览器向 DNS 请求解析域名的 IP 地址。域名服务器 DNS 解析出 IP 地址，浏览器与该服务器建立 TCP 连接（默认端口号为 80) 浏览器发出 HTTP 请求：GET/chn/index.html ，服务器通过 HTTP 响应把文件 index.htm 发送给浏览器 T，CP 连接释放，浏览器解释文件 index.htm，并将 Web 页显示给用户。</p>\n<h3 id=\"http特点\"><a class=\"anchor\" href=\"#http特点\">#</a> HTTP 特点</h3>\n<p>（1）<strong>HTTP 是无状态的</strong>，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。<br>\n（2）HTTP 的无状态特性简化了服务器的设计，使服务器更容易支持大温并发的 HTTP 请求。<br>\n（3）使用 Cookie 加数据库的方式来跟踪用户的活动。<br>\n（4）HTTP 采用 TCP 作为运输层协议，保证了数据的可靠传输。<br>\n（5）<strong>HTTP 既可以使用非持久连接，也可以使用持久连接 (HTTP/1.1 支持）</strong>。</p>\n<p><strong>非持久连接</strong>：每个网页元素对象（如 JPEG 图形、 Flash 等）的传输都需要单独建立一个 TCP 连接<br>\n<strong>持久连接</strong>：是指万维网服务器在发送响应后仍然保持这条连接，使同一个客户和服务器可以继续在这条连接上传送后续的 HTTP 请求与响应报文。<br>\n持久连接还分为流水线和非流水线，非流水线：客户在收到前一个响应后才能发出下一个请求。流水线：客户每遇到一个对象引用 ，就立即发出一个请求。</p>\n<h3 id=\"http报文结构\"><a class=\"anchor\" href=\"#http报文结构\">#</a> HTTP 报文结构</h3>\n<p>HTTP 是面向文本的，HTTP 报文分为请求报文和响应报文。请求报文：从客户向服务器发送的请求报文。响应报文：从服务器到客户的回答。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210221114057219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTgzMDEw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>方法操作为：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210221114207824.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"状态码\"><a class=\"anchor\" href=\"#状态码\">#</a> 状态码</h3>\n<p>1xx 表示通知信息的，如请求收到了或正在处理。<br>\n2xx 表示成功，如接受或知道了。<br>\n3xx 表示重定向，如要完成请求还必须采取进一步的行动。<br>\n4xx 表示客户的差错，如请求中有错误的语法或不能完成。如：404.<br>\n5xx 表示服务器的差错，如服务器失效无法完成请求</p>\n<p><img data-src=\"image-20211117160518399.png\" alt=\"image-20211117160518399\"></p>\n",
            "tags": [
                "考研",
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2021/11/16/%E4%BC%A0%E8%BE%93%E5%B1%82/",
            "url": "http://example.com/2021/11/16/%E4%BC%A0%E8%BE%93%E5%B1%82/",
            "title": "传输层",
            "date_published": "2021-11-16T01:16:16.000Z",
            "content_html": "<h1 id=\"传输层提供的服务\"><a class=\"anchor\" href=\"#传输层提供的服务\">#</a> 传输层提供的服务</h1>\n<h3 id=\"传输层的功能\"><a class=\"anchor\" href=\"#传输层的功能\">#</a> 传输层的功能</h3>\n<p>​    （1）传输层提供了应用进程之间的逻辑通信（即端到端的通信）。<br>\n​    （2）<strong>复用和分用。复用是指发送方不同的应用进程，都可使用同一个传输层协议传送数据。分用是指接收方的传输层在剥去报文的首部后，能够把这些数据正确交付到目的应用进程</strong>。<br>\n​    （3）传输层还要对收到的报文进行差错检测（首部和数据部分）而网络层只检查 IP 数据报的首部，不检验数据部分是否出错。<br>\n​    （4）提供两种不同的传输协议，即面向连接的 TCP 和无连接的 UDP。而网络层无法同时实现两种协议（即在网络层要么只提供面向连接的服务，要么只提供无连接服务）。<br>\n​    传输层向高层用户屏蔽低层网络核心的细节（如网络拓扑、路由协议等），使应用进程好像在两个传输层实体之间有一条端到端的逻辑通信信道。</p>\n<h3 id=\"端口号\"><a class=\"anchor\" href=\"#端口号\">#</a> 端口号</h3>\n<p>应用进程通过进程号进行标识，端口号长度为 64bit，能够表示 65536（2^16）个不同的端口号。<strong>端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的</strong>。根据端口号范围可将端口号分为两类：</p>\n<p>1）<strong>服务端使用的端口号</strong>。它又分为两类，最重要的一类是熟知端口号，数值为 0~1023. 另一类是登记端口号。使用这类端口号必须在 IANA 登记，以防止重复。一些熟知端口号如下：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210220161438849.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><strong>客户端使用的端口号（49152~65535）又称短暂端口号（也称临时端口）</strong>：这类端口号仅在客户进程运行时才动态地选择，通信结束后，刚用过的客户端口号就 不复存在，从而这个端口号就可供其他客户进程使用。</p>\n<h3 id=\"tcpip协议栈的传输协议\"><a class=\"anchor\" href=\"#tcpip协议栈的传输协议\">#</a> TCP/IP 协议栈的传输协议</h3>\n<p>​    面向连接的传输控制协议 (TCP)：采用 TCP 时，传输层向上提供的是一条全双工的可靠逻辑信道。TCP 提供面向连接的可靠传输服务，主要适用于可靠性更重要的场合，如文件传输协议 (FTP)、超文本传输协议（HTTP）、远程登录（TELNET）等。但也增加了许多开销，如确认、流量控制、计时器及连接管理等。<br>\n​    无连接的用户数据报协议 (UDP) ：采用 UDP 时，传输层向上提供的是一条不可靠的逻辑通道。远程主机的传输层收到 UDP 报文后，不需要给出任何确认。UDP 简单，执行速度比较快、实时性比较好。应用于小文件传送协议（TFTP）、DNS、SNMP 和实时传输协议（RTP）。</p>\n<h3 id=\"ip数据报与udp数据报的区别\"><a class=\"anchor\" href=\"#ip数据报与udp数据报的区别\">#</a> IP 数据报与 UDP 数据报的区别</h3>\n<p>​    IP 数据报在网络层要经过路由的存储转发。<br>\n​    UDP 数据报在传输层的端到端的逻辑信道中传输，封装成 IP 数据报在网络层传输时，UDP 数据报的信息对路由是不可见的。</p>\n<h3 id=\"tcp与网络层虚电路的区别\"><a class=\"anchor\" href=\"#tcp与网络层虚电路的区别\">#</a> TCP 与网络层虚电路的区别</h3>\n<p>​    TCP 报文段在传输层抽象的逻辑信道中传输，对路由器不可见。虚电路所经过的交换结点都必须保存虚电路状态信息。<br>\n​    网络层若采用虚电路方式，则无法提供无连接服务，而传输层采用 TCP 不影晌网络层提供无连接服务。</p>\n<h1 id=\"udp协议\"><a class=\"anchor\" href=\"#udp协议\">#</a> UDP 协议</h1>\n<p>复用和分用以及差错检测（没有流量控制）</p>\n<h3 id=\"udp的特点\"><a class=\"anchor\" href=\"#udp的特点\">#</a> UDP 的特点</h3>\n<p>（1）UDP 常用于一次性传输较少数据的网络应用，如<strong> DNS、SNMP</strong> 等。<br>\n（2）UDP 提供尽最大努力的交付，即不保证可靠交付，所有维  护传输可靠性的工作需要用户在应用层来完成。<br>\n（3）UDP 是<strong>面向报文</strong>的，报文是 UDP 数据报处理的最小单位。</p>\n<h3 id=\"udp的首部格式\"><a class=\"anchor\" href=\"#udp的首部格式\">#</a> UDP 的首部格式</h3>\n<p><strong>源端口</strong>：源端口号。在需要对方回信时选用，不需要时可用全 0<br>\n<strong> 目的端口</strong>：这在终点交付报文时必须使用到。<br>\n<strong>长度</strong>：UDP 数据报的长度（包括首部和数据），其最小值是 8 （仅有首部）</p>\n<p><strong>校验和</strong>：该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全 0，检测 UDP 数据报在传输中是否有错．有错就丢弃。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20190915204452321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW9tdWJhaQ==,size_16,color_FFFFFF,t_70\" alt=\"img\"></p>\n<h2 id=\"udp校验\"><a class=\"anchor\" href=\"#udp校验\">#</a> UDP 校验</h2>\n<p>UDP 的校验和只检查首部和数据部分。<br>\n校验时，<strong>若 UDP 数据报部分的长度不是偶数个字节，则需填入个全 0 字节</strong>。<br>\n如果 UDP 校验和校验出 UDP 数据报是错误的，那么可以丢弃，也可以交付给上层，但是需要附上错误报告（不能直接交给上层）。</p>\n<p>通过<strong>伪首部</strong>，不仅可以检查源端口号、目的端口号和 UDP 用户数据报的数据部分还可以检查 IP 数据报的源 IP 地址和目的地址。</p>\n<p><img data-src=\"image-20211116104339964.png\" alt=\"image-20211116104339964\"></p>\n<h1 id=\"tcp协议\"><a class=\"anchor\" href=\"#tcp协议\">#</a> TCP 协议</h1>\n<p>TCP 是在不可靠的 IP 层之上实现的可靠的数据传输协议，它主要解决传输的可靠、有序、 无丢失和不重复问题。</p>\n<h2 id=\"tcp协议的特点\"><a class=\"anchor\" href=\"#tcp协议的特点\">#</a> TCP 协议的特点</h2>\n<p>（1）TCP 是面向连接的传输层协议。<br>\n（2）每条 TCP 连接只能有两个端点，每条 TCP 连接只能是点对点的（一对一）。<br>\n（3）TCP 提供可靠的交付服务，保证传送的数据无差值、部队是、不重复且有序。</p>\n<p>（4）TCP 提供<strong>全双工通信</strong>，允许通信双方的应用进程在任何时候都能发送数据，为此 TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。<br>\n（5）TCP 是面向字节流的。</p>\n<p><img data-src=\"https://img-blog.csdn.net/20140609125220296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTE5ODgxMDI5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\"></p>\n<p>TCP 报文段各字段的意义：<br>\n源端口和目的端口字段：各占 2B，端口是运输层与应用层的版务接口，运输层的复用和分用功能都要通过端口实现。<br>\n序号字段：占 4B, TCP 是面向字节流的（即 TCP 传送时是逐个字节传送的），所以 TCP 连接传送的数据流中的每个字节都编上一个序号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号。<br>\n确认号字段：占 4B，是期望收到对方的下一个报文段的数据的第一个字节的序号。<br>\n数据偏移（即首部长度）：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。<br>\n保留字段：占 6 位，保留为今后使用。<br>\n紧急位 URG: URG= 1 时，表明紧急指针字段有效。它告诉系统报文段中有紧急数据，应尽快传送（相当于高优先级的数据）。<br>\n确认位 ACK：ACK=1 时确认号字段才有效，ACK=0 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1<br>\n 推送位 PSH (Push) ：接收 TCP 收到 PSH=l 的报文段 ，就尽快地交付给接收应用进程 ，而不再等到整个缓存都填满后再向上交付<br>\n复位位 RST (Reset) : RST=l 时，表明 TCP 连接中出现严重差错（如主机崩溃或其他原因），必须释放连接 ，然后再重新建立运输连接<br>\n同步位 SYN: SYN=l 表示这是一个连接请求或连接接收报文<br>\n终止位 FIN (Finish)：用来释放一个连接。 FIN= 1 表明 此报文段的发送方的数据已发送完毕，并要求释放传输连接<br>\n窗口字段：占 2B，表示允许对方发送的数据量，单位为字节<br>\n校验和：占 2B，校验和 字段检验的范圈包括首部 和数据两部分<br>\n紧急指针字段：占 16 位，指出在本报文段中紧急数据共有多少字节（紧急数据 放在本报文段数据的最前面）<br>\n选项字段：长度可变，TCP 最初只规定了一种选项，即最大报文段长度<br>\n填充字段：使整个首部长度 是 4B 的整数倍</p>\n<h2 id=\"tcp连接管理\"><a class=\"anchor\" href=\"#tcp连接管理\">#</a> TCP 连接管理</h2>\n<p>TCP 连接的阶段分为三部分：<strong>连接建立、数据传送和连接释放</strong>。TCP 连接的端点不是主机，不是主机的 IP 地址而是<strong>套接字</strong>，每条 TCP 连接唯一地被通信的两个端点（即两个套接字）确定。</p>\n<h3 id=\"连接的建立三次握手\"><a class=\"anchor\" href=\"#连接的建立三次握手\">#</a> 连接的建立（三次握手）</h3>\n<p>（1）客户机的 TCP 首先向服务器的 TCP 发送一个连接请求报文段 SYN=1,seq=x。<br>\n（2）服务器的 TCP 收到连接请求拫文段后，如同意建立连接，就向客户机发回确认，并为该 TCP 连接分配 TCP 缓存和变量，SYN=1,ACK=1,ack=x+1,seq=y.<br>\n（3）当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量，ACK=1,seq=x+1,ack=y+1.（携带数据）</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210220235256399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTgzMDEw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><span class=\"rainbow\">连接已经建立时，再次建立会失败</span></p>\n<h3 id=\"syn洪泛攻击\"><a class=\"anchor\" href=\"#syn洪泛攻击\">#</a> SYN 洪泛攻击</h3>\n<p>SYN 洪泛攻击发生在 OSI 第四层，这种方式利用 TCP 协议的特性，就是三次握手，攻击者发送 TCP SYN，SYN 是 TCP 三次握手中的第一个数据包，而当服务器返回 ACK 后，该攻击者就不对其进行再确认，那这个 TCP 连接就处千挂起状态 也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送 ACK 给攻击者。<br>\nSYN 洪泛攻击会浪费服务器的资源，在服务器上，这些 TCP 连接会因为挂起状态而消耗 CPU 和内存，最后服务器可能死机。</p>\n<h3 id=\"连接的释放四次挥手\"><a class=\"anchor\" href=\"#连接的释放四次挥手\">#</a> 连接的释放（四次挥手）</h3>\n<p>（1）客户机向其 TCP 发送一个连接释放拫文段，并停止发送数据，主动关闭 TCP 连接，FIN=1,seq=u.<br>\n（2）服务器收到连接释放报文段后即发出确认，ACK=1,seq=v,ack=u+1.<br>\n（3）服务器通知客户端 TCP 释放连接，FIN=1,ACK=1,seq=w,ack=u+1.<br>\n（4）客户机受到连接释放报文后，发出确认，ACK=1,seq=u+1，ack=w+1。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210220235307287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTgzMDEw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"tcp可靠传输\"><a class=\"anchor\" href=\"#tcp可靠传输\">#</a> TCP 可靠传输</h2>\n<p>TCP 首部的序号字段用来保证数据能有序提交给应用层 ，序号建立在传送的字节流之上 TCP 首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号，TCP 默认使用累计确认 ，即 TCP 只确认数据流中至第一个丢失字节为止的字节。TCP 每发送一个报文段 ， 就对这个报文段设置一次计时器。计时器设置的至传时间到期但还未收到确认时，就要重传这一报文段。再次确认某个报文段的 ACK 而发送方先前已经收到过该报文段的确认，<strong>当收到对于某个报文段的，3 个冗余 ACK ， 可以认为该报文段已经丢失</strong>。这时发送方可以立即对该报文执行重传。</p>\n<h2 id=\"tcp流量控制\"><a class=\"anchor\" href=\"#tcp流量控制\">#</a> TCP 流量控制</h2>\n<p>TCP 流量控制基于滑动窗口协议的流量控制机制。接收方根据自己接收缓存的大小 ，动态地调整发送方的发送窗口大小（接收窗口 rwnd) ，限制发送方向网络注入报文的速率发送方根据其对当前网络拥塞程序的估计而确定的窗口值 ，这称为拥塞窗口 cwnd 其大小与网络的带宽和时延有关。<br>\n<strong>传输层与数据链路层的区别</strong>：传输层的流量控制机制定义了端到端用户之间的流量控制，数据链路层的；流量控制机制定义了两个中间的相邻结点的流量控制。而且在传输层滑动窗口可以动态变化，数据链路层的滑动窗口不能动态变化。<br>\n<span class=\"rainbow\">滑动窗口过小，会产生过多的 ACK；滑动窗口过大，会使路由器变得拥挤，主机可能丢失分组</span></p>\n<p><span ,rainbow>发送窗口 = min {接受窗口，拥塞窗口 /}</span></p>\n<p><span class=\"rainbow\">窗口值 1000=1000B</span></p>\n<h2 id=\"tcp拥塞控制\"><a class=\"anchor\" href=\"#tcp拥塞控制\">#</a> TCP 拥塞控制</h2>\n<p><strong>接收窗口 rwnd</strong>：接收方根据目前接收缓存大小所许诺的最新窗口值 ， 反映接收方的容量<br>\n<strong>拥塞窗口 cwnd</strong> ：发送方根据自己估算的网络拥塞程度而设置的窗口值 ， 反映网络的当前容量</p>\n<h3 id=\"实现机制\"><a class=\"anchor\" href=\"#实现机制\">#</a> 实现机制</h3>\n<p><strong>慢开始</strong>：每经过一个传输轮次（即往返时延 RTT)，拥塞窗口 cwnd 就会加倍令拥塞窗口 cwnd = 1 即 — 个最大报文段长度 MSS ， 每收到 — 个对新报文段的确认后 ， 将 cwnd 加 1 使分组注入网络的速率更加合理，慢开始一直把拥塞窗口 cwnd 增大到一个规定的慢开始门限 ssthresh （阈值），然后改用拥塞避免算法。<br>\n<strong>拥塞避免</strong>：发送端的拥塞窗口 cwnd 每经过一个往返时延 RTT 就增加一个 MSS 的大小，而不是加倍，cwnd 按线性规律缓慢增长（即加法增大），而当出现 — 次超时（网络拥塞） 时 ， 令慢开始门限 ssthresh 等于当前 cwnd 的 — 半（即乘法减小）。<br>\n<strong>快重传</strong>：当发送方连续收到三个重复的 ACK 报文时 ， 直接噩传对方尚未收到的报文段 ， 而不必等待那个报文段设置的重传计时器超时。<br>\n<strong>快恢复</strong>：发送端收到连续三个冗余 ACK （即重要确认）时 ， 执行 “乘法减小” 算法，把慢开始门限 ssthresh 设置为出现拥塞时发送方 cwnd 的一半。<br>\n<strong>网络拥塞的处理</strong>：发送方检测到超时事件的发生（未按时收到确认 ， 重传计时器超时），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方的 cwnd 值的一半（但不能小于 2) 然后把拥塞窗口 cwnd 重新设置为 L 执行慢开始算法。<br>\n<img data-src=\"https://img-blog.csdnimg.cn/20210220235137474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTgzMDEw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<hr>\n<p><img data-src=\"image-20211117101900954.png\" alt=\"image-20211117101900954\"></p>\n<p><img data-src=\"image-20211117101938147.png\" alt=\"image-20211117101938147\"></p>\n<p><img data-src=\"image-20211117102014708.png\" alt=\"image-20211117102014708\"></p>\n<p><img data-src=\"image-20211117102030910.png\" alt=\"image-20211117102030910\"></p>\n<p><img data-src=\"image-20211117102048486.png\" alt=\"image-20211117102048486\"></p>\n<p><img data-src=\"image-20211117102146824.png\" alt=\"image-20211117102146824\"></p>\n",
            "tags": [
                "考研",
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2021/11/14/%E7%BD%91%E7%BB%9C%E5%B1%82/",
            "url": "http://example.com/2021/11/14/%E7%BD%91%E7%BB%9C%E5%B1%82/",
            "title": "网络层",
            "date_published": "2021-11-14T02:13:07.000Z",
            "content_html": "<h2 id=\"网络层功能\"><a class=\"anchor\" href=\"#网络层功能\">#</a> 网络层功能</h2>\n<p><strong>异构网络互联</strong>（数据链路层和物理层均不同）：物理层和数据链路层中继器只是扩大网络，不能网络互联</p>\n<p><strong>虚拟互联网络</strong>（也称为逻辑互联网络）是指互联起来的各种物理网络的异构性本来是客观存在的但是通过 IP 就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。这种使用 IP 的虚拟互联网络可以简称为 IP 网络。</p>\n<p><strong>路由与转发</strong>：路由器连接的网络，网络层及以下可以不同，网络层以上必须相同</p>\n<p><strong>拥塞控制</strong>：开环控制（静态），闭环控制（动态）</p>\n<h2 id=\"ipv4\"><a class=\"anchor\" href=\"#ipv4\">#</a> IPV4</h2>\n<p>IP 分组格式<br>\n版本：4 位，指 IP 版本，目前广泛使用的版本号是 4<br>\n 首部长度：占 4 位。 基本单位为 4B, 最大值为 60B (15<em><strong>4B</strong>) ，最常用的首部长度是 20B<br>\n 总长度：占 16 位。 基本</em><em>单位为 1B</em>* 指首部与数据之和的长度最大长度 65535B.<br>\n 标识：占 16 位。 是 个计数器用千保证数据报片能够正确组装称为原来的数据报<br>\n标志：占 3 位最低位 MF=l 代表分片 中间位 DF=0 代表可以分<br>\n片偏移：占 13 位<strong>基本单位为 8B <strong>指出分片后，某片在 原分组中的相对位置。<br>\n首部校验和：占 16 位 IP 数据报的首部校验和只校验分组的首部，而不校验数据部分。<br>\n生存时间 TTL: 占 8 位保证分组不会在网络中循环</strong>每次路由转发 TTL-1 当 TTL 为 0 丢弃该分组</strong>。<br>\n协议：占 8 位 指出该分组使用的协议 (<strong>6 为 TCP 协议 17 为 U DP 协议</strong>）。<br>\n源地址字段：占 4B 标识发送发的 IP 地址。<br>\n目的地址字段：占 4B 标识接收方的 IP 地址。</p>\n<h3 id=\"ip数据报分片\"><a class=\"anchor\" href=\"#ip数据报分片\">#</a> IP 数据报分片</h3>\n<p><strong>最大传送单元（MTU）</strong>：一个链路层数据报所能承载在的最大数据量。以太网：1500B，广域网：一般不超过 576B.<strong>IP 数据报分片</strong>：当数据报长度大于链路 MTU 时，就要对其进行分片传输。分片会在目的地进行组装，不会在中间路由处进行组装。</p>\n<p>标志位含义：<strong>MF (more fragment )</strong> ：为 1 代表进行了分片。<strong>DF (don’t fragment)</strong>：为 0 时才可以进行分片。</p>\n<h3 id=\"网络层转发分组的流程\"><a class=\"anchor\" href=\"#网络层转发分组的流程\">#</a> 网络层转发分组的流程</h3>\n<p>(1) 直接交付</p>\n<p>（2）1 不成功，则间接交付</p>\n<p>（3）2 不成功，找特定路由（通常为了控制和测试网络，如<strong>域名服务器</strong>）</p>\n<p>（4）3 不成功，则交由默认路由（如<strong>互联网</strong>）</p>\n<h2 id=\"ipv4地址\"><a class=\"anchor\" href=\"#ipv4地址\">#</a> IPV4 地址</h2>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210219164153297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTgzMDEw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210219164231920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTgzMDEw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"网络地址转换nat\"><a class=\"anchor\" href=\"#网络地址转换nat\">#</a> 网络地址转换（NAT）</h4>\n<p><span class=\"rainbow\">普通路由器仅工作在网络层，NAT 路由器还要查看和转换传输层的端口号</span></p>\n<p><span class=\"rainbow\">只有管理员能添加 NAT 表，在 NET 找不到对应端口后就要抛弃分组</span></p>\n<p><img data-src=\"image-20211114165914831.png\" alt=\"image-20211114165914831\"></p>\n<h4 id=\"子网划分与子网掩码cidr\"><a class=\"anchor\" href=\"#子网划分与子网掩码cidr\">#</a> 子网划分与子网掩码，CIDR</h4>\n<p><span class=\"rainbow\">子网划分可平均划分，和变长划分</span></p>\n<p><strong>默认路由，路由聚合可用于路由器表项合并</strong></p>\n<p><strong>子网不能全 0 和全 1，子网号全为 0 为本网络号，全为 1 为子网的广播地址</strong></p>\n<p>在使用子网掩码的情况下：<br>\n（1）一台主机设置 IP 地址的同时必须设置子网掩码。<br>\n（2）同属于一个子网的所有主机及路由器的相应端口，必须设置相同的子网掩码。<br>\n（3）路由表中必须包含有网络地址，子网掩码和下一跳地址。</p>\n<p><span class=\"rainbow\">CIDR 把小的网络汇聚成大的网络</span></p>\n<p><strong>构成超网</strong></p>\n<p><strong>最长前缀匹配</strong></p>\n<h4 id=\"ip地址与硬件地址\"><a class=\"anchor\" href=\"#ip地址与硬件地址\">#</a> IP 地址与硬件地址</h4>\n<p>IP 地址是网络层使用的地址，它是分层次等级的。硬件地址是数据链路层使用的地址，它是平面式的。在网络层及网络层之上使用 IP 地址，IP 地址放在 IP 数据报的首部，而 MAC 地址放在 MAC 帧的首部，数据链路层看不见数据报分组中的 IP 地址。<strong>在网络层中的路由器相互传输时使用 IP 地址，当到达目标网络后，使用 MAC 地址查找目标物理主机</strong>。（路由器由于互联多个网络，因此他不仅有多个 IP 地址，也有多个 MAC 地址。）</p>\n<h4 id=\"地址解析协议arp\"><a class=\"anchor\" href=\"#地址解析协议arp\">#</a> 地址解析协议（ARP）</h4>\n<p><strong>地址解析协议（ARP）实现了 IP 地址到 MAC 地址的映射</strong>。每台主机都设有一个 ARP 高速缓存，用来存放本局域网上各主机和路由器的 IP 地址到 MAC 地址的映射表，称为 ARP 表。</p>\n<p><span class=\"rainbow\">ARP 表上没有找到物理地址，目的 MAC 地址就用 ff-ff-ff-ff</span></p>\n<p><strong>ARP 的 4 种典型情况总结如下：</strong></p>\n<p>（1）发送方是主机时，要把 IP 数据报发送到本网络上的另一台主机：这时用 ARP 找到目的主机的硬件地址<br>\n（2）发送方是主机时，要把 IP 数据报发送到另一个网络上的一台主机 这时用 ARP 找到本网络上的一个路由器的硬件地址，剩下的工作由这个路由器来完成。<br>\n（3）发送方是路由器时，要把 IP 数据报转发到本网络上的 — 台主机，这时用 ARP 找到目的主机的硬件地址<br>\n（4）发送方是路由器时，要把 IP 数据报转发到本网络上的 — 台主机：这时用 ARP 找到本网络上的一个路由器的硬件地址，剩下的工作由这个路由器来完成。</p>\n<h4 id=\"动态主机配置协议dhcp\"><a class=\"anchor\" href=\"#动态主机配置协议dhcp\">#</a> 动态主机配置协议（DHCP）</h4>\n<p><strong>DHCP 是应用层协议，它是基于 UDP 的</strong>。使用<strong>客户 / 服务器模式</strong>，通过<strong>广播方式交互</strong></p>\n<p>动态主机配置协议（DHCP）实现过程如下：<br>\n（1）DHCP 客户机广播 “DHCP 发现” 消息，试图找到网络中的 DHCP 服务器，以便从 DHCP 服务器中获得一个 IP 地址。<br>\n（2）DHCP 服务器收到 DHCP 发现 消息后，向网络中广播，DHCP 提供 “消息，其中包括提供 DHCP 客户机的 IP 地址和柜关配置信息。<br>\n（3）DHCP 客户机收到 DHCP 提供消息，如果接收 DHCP 服务器所提供的相关参数，那么通过广播 DHCP 请求消息向 DHCP 服务器请求提供 IP 地址。<br>\n（4）DHCP 服务器广播，DHCP 确认消息，将 IP 地址分配给 DHCP 客户机。<br>\nDHCP 服务器分配给 DHCP 客户的 IP 地址是<strong>临时的</strong>，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址 DHCP 的客户端和服务器端需要通过广播方式来进行交互。</p>\n<h4 id=\"网际控制报文协议icmp\"><a class=\"anchor\" href=\"#网际控制报文协议icmp\">#</a> 网际控制报文协议（ICMP）</h4>\n<p><strong>ICMP 差错报告报文</strong></p>\n<p><strong>终点不可达</strong>：当路由器或主机不能交付数据报时，就向源点发送终点不可达报文。<br>\n<strong>源点抑制</strong>：当路由器或主机由于<strong>拥塞而丢弃数据</strong>报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。</p>\n<p><strong>时间超过</strong>：当路由器收到生存时间 <strong>(TTL) 为零</strong>的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。<br>\n<strong>参数问题</strong>：当路由器或目的主机收到的数据报的<strong>首部中有的字段的值不正确</strong>时，就丢弃该数据报，并向源点发送参数问题报文。</p>\n<p><strong>改变路由（重定向）</strong>：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器。</p>\n<p><strong>不应发送 ICMP 差错报告报文的情况有以下四种情况</strong>：<br>\n（1）对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。<br>\n（2）对第 — 个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。</p>\n<p>（3）对具有组播地址的数据报都不发送 ICMP 差错报告报文。<br>\n（4）对具有特殊地址（如 127.0.0.0 或 0.0.0.0) 的数据报不发送 ICMP 差错报告报文。</p>\n<p><strong>ICMP 询问报文</strong>有 4 种类型：回送请求和回答报文、时间戳请求和回答报文、掩码地址请求和回答报文、路由器询问和通告报文。</p>\n<p><strong>ICMP 常见的两个应用是分组网间探测 PING 和 Traceroute</strong>.<br>\n<strong> 分组网间探测 PING</strong>（工作在应用层）：使用了 ICMP 回送请求和回答报文，用来测试两台主机之间的连通性。<br>\n<strong>Traceroute</strong>（在网络层）：使用了 ICMP 时间超过报文，用来跟踪分组经过的路由。</p>\n<h2 id=\"ipv6\"><a class=\"anchor\" href=\"#ipv6\">#</a> IPV6</h2>\n<p>（1）<strong>更大的地址空间 IPv6 将地址从 IPv4 的 32 位增大到了 128 位</strong>。<br>\n（2）扩展的地址层次结构。<br>\n（3）<strong>扩展首部</strong><br>\n（4）改进的选项。<br>\n（5）允许协议继续扩充。<br>\n（6）支持<strong>即插即用</strong>（即自动配置）。<br>\n（7）支持资源的预分配。<br>\n（8）<strong>IPv6 只有在包的源结点才能分片，是端到端的，传输路径中的路由器不能分片。</strong><br>\n（9）<strong>IPv6 首部长度必须是 8B 的整数倍，而 IPv4 首部是 4B 的整数倍。</strong><br>\n（10）增大了安全性。 身份验证和保密功能是 IPv6 的关键特征。</p>\n<p><strong>IPV6 地址缩写</strong>：当 16 位域的开头由一些 0 时，可以采用一种缩写表示法，但在域中必须至少有一个数字。当有相继的 0 值域时，还可以进一部缩写，将这些域可以用双冒号进行缩写（::）.</p>\n<hr>\n<p>IPV6 数据报的目的地址可以是以下三种基本类型地址之一：</p>\n<p>（1）<strong>单播</strong>。单播就是传统的点对点通信。<br>\n（2）<strong>多播</strong>。多播是一点对多点的通信，分组被交付到一组计算机的每台计算机。<br>\n（3）<strong>任播</strong>。这是 IPV6 新增加的一种类型。任播的目的站是一组计算机，但数据报在交付时只交付其中的一台计算机，通常是距离最近的一台计算机。</p>\n<hr>\n<p>IPV4 向 IPV6 过渡可以采用双协议栈和隧道技术两种策略。</p>\n<p><strong>双协议栈</strong>：双协议栈技术是指在一台设备上同时装有 IPV4 和 IPV6 协议栈，那么这台设备既能和 IPV4 网络通信，又能和 IPV6 网络通信。<br>\n<strong>隧道技术</strong>：将整个 IPv6 数据报封装到 IPv4 数据报的数据部分，使得 IPv6 数据报可以在 IPv4 网络的隧道中传输。</p>\n<h2 id=\"路由协议\"><a class=\"anchor\" href=\"#路由协议\">#</a> 路由协议</h2>\n<p><strong>自治系统（AS）</strong>：单一技术管理下的一组路由器，这些路由器使用一种 AS 内部的路由选择协议和共同度量来确定分组在该 AS 内的路由。同时还使用一种 AS 之间的路由选择协议来确定分组在 AS 之间的路由。</p>\n<pre><code>内部网关协议(IGP，域内路由选择，AS内）:在一个自治系统内部使用的路由选择协议，目前这类路由选择协议使用得最多，如RIP和OSPF.\n外部网关协议(EGP，域间路由选择，AS外）:源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时需要使用一种协议将路由选择信息传递到另一个自治系统中。目前使用最多的外部网关协议是BGP-4.\n</code></pre>\n<h3 id=\"路由信息协议rip应用层\"><a class=\"anchor\" href=\"#路由信息协议rip应用层\">#</a> 路由信息协议（RIP）（应用层）</h3>\n<p><strong>路由信息协议（RIP）</strong>：内部网关协议 (IGP) 中最先得到广泛应用的协议。RIP 是一种分布式的，基于距离向量的路由选择协议，其最大的优点就是简单。</p>\n<p><strong>RIP 的规定：</strong><br>\n1. 网络中的每个路由器都要维护从他自身到其他每个目的网络的距离记录。<br>\n2. 距离也称跳数，规定从一个路由器到直接连接网络的距离（跳数）为 1。<br>\n3.RIP 认为好的路由就是它通过的路由器的数目少，即优先选择跳数小的路径。<br>\n4.<strong>RIP 允许一条路径最多只能包含 15 个路由器，因此距离等于 16 时，它表示网络不可达</strong>。<br>\n5.RIP 默认在任意两个使用 RIP 的路由器<strong>每 30 秒广播 — 次</strong> RIP 路由更新信息，以便自动建立并维护路由表，<strong>超过 180 秒没收到更新，则直接更新</strong>。<br>\n6. 在 RIP 中不支持子网掩码的 RIP 广播，所以 RIP 中每个网络的子网掩码必须相同。</p>\n<p><strong>RIP 的特点</strong>：<br>\n（1）实现简单，开销小，收敛过程快。<br>\n（2）网络规模小，16<br>\n（3）坏消息传的慢</p>\n<p><strong>RIP 是应用层协议，他使用 UDP 传送数据（端口 520）。RIP 选择的路径不一定是时间最短的，但一定是具有最少路由器的路径</strong>。</p>\n<h3 id=\"距离向量算法\"><a class=\"anchor\" href=\"#距离向量算法\">#</a> 距离向量算法</h3>\n<p>关键点：1. 原来路由表有目的地址 N，且下一跳路由器地址是 X，则替换（不管变大变小，都以实时为准 c）</p>\n<p>2. 只有收到的距离<strong>小于</strong>原来的距离才替换，<strong>等于</strong>不替换</p>\n<h3 id=\"放最短路径优先协议ospf网络层\"><a class=\"anchor\" href=\"#放最短路径优先协议ospf网络层\">#</a> 放最短路径优先协议（OSPF）（网络层）</h3>\n<p>使用分布式链路状态路由算法</p>\n<p><strong>OSPF 的特点</strong><br>\n（1）OSPF 对不同的链路可根据 IP 分组的不同服务类型 (TOS) 而设置成不同的代价。<br>\n（2）OSPF 对于不同类型的业务可计算出不同的路由，十分灵活。<br>\n（3）多路径间负载平衡：如果到同 — 个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。<br>\n（4）所有在 OSPF 路由器之间交换的分组都具有鉴别功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。<br>\n（5）支持可变长度的子网划分和无分类编址 CIDR。<br>\n（6）每个链路状态都带上 — 个 32 位的序号，序号越大，状态就越新。</p>\n<p>​\t（7）每隔一段时间刷新数据库中的链路状态</p>\n<p>.<strong>OSPF 的五种分组类型</strong><br>\n（HELLO）问候分组：用来发现和维持邻站的可达性。<br>\n数据库描述分组：向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。<br>\n链路状态请求分组：向对方请求发送某些链路状态项目的详细信息。<br>\n链路状态更新分组：用洪泛法对全网更新链路状态。<br>\n链路状态确认分组：对链路更新分组的确认。</p>\n<h3 id=\"边界网关协议bgp\"><a class=\"anchor\" href=\"#边界网关协议bgp\">#</a> 边界网关协议（BGP）</h3>\n<p>** 边界网关协议（BGP）** 是不同自治系统的路由器之间交换路由信息的协议，是 — 种外部网关协议边界网关协议常用于互联网的网关之间，BGP 采用的是路径向量路由选择协议，它是一个应用层协议，<strong>基于 TCP</strong>。</p>\n<p><strong>打开 (Open) 报文</strong>：用来与相邻的另 — 个 BGP 发言人建立关系。<br>\n<strong>更新 (Update) 报文</strong>：用来发送某一路由的信息，以及列出要撤销的多条路由。</p>\n<p><strong>保活 (Keepalive) 报文</strong>：用来确认打开报文并周期性地证实邻站关系。<br>\n<strong>通知 (Notification) 报文</strong>：用来发送检测到的差错。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210220105520173.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTgzMDEw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"路由算法\"><a class=\"anchor\" href=\"#路由算法\">#</a> 路由算法</h2>\n<p><strong>静态路由算法</strong>：由网络管理员手工配置的路由信息。对于简单的小型网络可以采用静态路由。</p>\n<p><strong>动态路由算法</strong>：改善网络的性能并有助于流量控制，但是算法过于复杂，会增加网络的负担，对动态变化的反应太快而引起振荡，或反应太慢而影晌网络路由的一致性。</p>\n<h2 id=\"ip组播屁都没讲清楚真的笑了\"><a class=\"anchor\" href=\"#ip组播屁都没讲清楚真的笑了\">#</a> IP 组播（屁都没讲清楚，真的笑了）</h2>\n<p>组播机制是让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机，并被他们正确接收。组播仅应用于 UDP。<strong>组播需要路由器的支持才能实现，能够运行组播协议的路由器称为组播路由器</strong>。</p>\n<p>播实现过程：主机使用一个称为 IGMP 的协议加入组播组，使用该协议通知本地网络上的路由器关于要接收发送给某个组播组的分组的愿望，通过扩展路由器的路由选择和转发功能，可以在许多路由器互联的支持硬件组播的网络上面实现因特网组播。组播技术使得数据只需发送一次就可发送到所有接收者，大大减轻了网络的负载和发送者的负担。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210220111938490.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTgzMDEw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"ip组播地址\"><a class=\"anchor\" href=\"#ip组播地址\">#</a> IP 组播地址</h3>\n<p>IP 组播地址使用<strong> D 类地址格式</strong>，D 类地址的前四位是 1110，因此 D 类地址范围是 224.0.0.0~239.255.255.255，每个 D 类 IP 地址标志一个组播组。<strong>并不是所有 D 类地址都可以用，有些用于永久组播</strong></p>\n<p>组播数据报和一般的 IP 数据报的区别是，<strong>前者使用 D 类 IP 地址作为目的地址，并且首部中的协议字段值为 2，表明使用 IGMP</strong>。需要注意的是：</p>\n<p>1. 组播数据报也是 “尽最大努力交付”，不提供可靠交付。<br>\n2. 组播地址只能用于目的地址，不能用于源地址。<br>\n3. 对组播数据报不产生 ICMP 差错报文，因此若在 PING 命令后面键入组播地址，将永远不会收到回应。<br>\n4. 并非所有的 D 类地址都可以用作组播地址。</p>\n<p><strong>IP 组播可以分为两种一种在本局域网上进行硬件组播，另一种则在因特网的范围内进行组播</strong>。在因特网上进行组播的最后阶段，还是要把组播数据报在局域网上用硬件组播交付给组播组内的所有成员。</p>\n<p><img data-src=\"image-20211115191927230.png\" alt=\"image-20211115191927230\"></p>\n<p><strong>后 23 位进行映射</strong>硬件地址的映射关系不是唯一的，因此收到组播数据报的主机，还要在 IP 层利用软件进行过滤，把不是本主机要接收的数据报丢弃。</p>\n<h3 id=\"igmp与组播路由算法\"><a class=\"anchor\" href=\"#igmp与组播路由算法\">#</a> IGMP 与组播路由算法</h3>\n<p>IGMP 为 TCP/IP 协议栈的一部分其工作可以分为两个阶段：<br>\n<strong>第一个阶段</strong>：主机加入新的组播组时，该主机向组播组的组播地址发送一个 IGMP 报文，声明要成为该组的成员。本地的组播路由器收到 IGMP 报文后，将组成员关系转发给因特网上的其他组播路由器。<br>\n<strong>第二个阶段</strong>：本地组播路由器周期性地探询本地局域网上的主机，以便知道这些主机是否仍继续是组的成员。只要对某个组有一台主机响应，那么组播路由器就认为这个组是活跃的。一个组在经过几次的探询后仍然没有一台主机响应时，则不再将该组的成 员关系转发给其他的组播路由器。<br>\n<strong>实现因特网组播的路由算法</strong>：第一种是基于链路状态的路由选择，第二种是基于距离 - 向量的路由选择，第三种可以建立在任何路由器协议之上，因此成为协议无关的组播（PIM）。<br>\n<strong>为了避免环路，构建组播转发树</strong></p>\n<h2 id=\"移动ip\"><a class=\"anchor\" href=\"#移动ip\">#</a> 移动 IP</h2>\n<p>基于 IPV4 定义的三种功能实体：移动节点、本地代理和外部代理。<br>\n<strong>移动结点</strong> ：具有永久 IP 地址的移动结点。<br>\n<strong>本地代理</strong>：在 — 个网络环境中，— 个移动结点的永久 “居所” 被称为归属网络，在归属网络中代表移动结点执行移动管理功能的实体称为归属。<br>\n<strong>外部代理</strong>：在外部网络中帮助移动结点完成移动管理功能的实体称为外部代理。</p>\n<h3 id=\"移动ip通信过程\"><a class=\"anchor\" href=\"#移动ip通信过程\">#</a> 移动 IP 通信过程</h3>\n<p>1. 移动结点在本地网时，按传统的 TCP/IP 方式进行通信（在本地网中有固有的地址 ）。<br>\n2. 移动结点到一个外地网络时，移动结点向本地代理注册当前的位置地址，即转交地址。<br>\n3. 本地代理接收来自转交地址的注册后，会构建一条通向转交地址的隧道，本地地址会将截获的信息通过隧道发送给转交地址处<br>\n 4. 在转交地址处解除隧道封装，恢复成原来 IP 分组，最后送到移动结点。<br>\n5. 移动结点在外网通过外网的路由器或外部代理向通信对端发送 IP 数据包。<br>\n6. 移动结点来到另 — 个外网时，只需向本地代理更新注册的转交地址，就可继续通信。<br>\n7. 移动结点回到本地网时，移动结点向本地代理注销转交地址，这时移动结点又将使用传统的 TCP/IP 方式进行通信。</p>\n<h2 id=\"网络层设备\"><a class=\"anchor\" href=\"#网络层设备\">#</a> 网络层设备</h2>\n<h3 id=\"路由器工作过程\"><a class=\"anchor\" href=\"#路由器工作过程\">#</a> 路由器工作过程</h3>\n<p>当源主机和目标主机在同一个网络上时，直接交付无需经过路由器。<br>\n源主机和目标主机不在同一个网络上时，路由器按照转发表将数据报转发给下一个路由器，即间接交付。</p>\n<h3 id=\"路由器功能组成\"><a class=\"anchor\" href=\"#路由器功能组成\">#</a> 路由器功能组成</h3>\n<p>从结构上看，路由器由路由选择部分和分组转发部分组成。<br>\n路由选择部分也称控制部分，<strong>其核心构件是路由选择处理机</strong>。路由选择处理机的任务是：根据选定的路由选择协议构造出路由表和其他相邻路由器交换路由信息然后更新和维护路由表。</p>\n<p><strong>分组转发部分由三部分组成：交换结构、一组输入端口和一组输出端口</strong>。输入端口从物理层接收到的比特流中提取出链路层帧，进而从帧中提取出网络层数据报。输出端口则将数据报变为比特流发送到物理层。<strong>交换结构是路由器的关键部件</strong>，它根据转发表对分组进行处理，将从输入口进入的分组从一个合适的输出端口转发出去。<strong>有三种常用的交换方法：通过存储器进行交换、通过总线进行交换和通过互联网络进行交换</strong>。</p>\n<p>路由器主要完成两个功能：<strong>一是分组转发，二是路由计算</strong>。</p>\n<h3 id=\"路由器与网桥的-区别\"><a class=\"anchor\" href=\"#路由器与网桥的-区别\">#</a> 路由器与网桥的 区别</h3>\n<p>路由器与网桥的重要区别是：网桥与高层协议无关，路由器是面向协议的，依据网络地址进行操作，并进行路径选择、分段帧格式转换、对数据报的生存时间和流量进行控制等。</p>\n<h3 id=\"路由表与路由转发\"><a class=\"anchor\" href=\"#路由表与路由转发\">#</a> 路由表与路由转发</h3>\n<p>路由表（<strong>软件</strong>）是根据路由选择算法得出的，主要用途是路由选择。标准的路由表有 4 个部分：目的网络的 IP 地址、子网掩码、下一跳 IP 地址和接口。</p>\n<p>转发与路由选择的区别：转发（<strong>硬件或软件</strong>）指路由器根据转发表把收到的 IP 数据报从合适的端口转发出去，仅涉及一个路由器。而路由选择涉及很多路由器，路由表是许多路由器协同工作的结果。</p>\n",
            "tags": [
                "考研",
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2021/11/12/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/",
            "url": "http://example.com/2021/11/12/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/",
            "title": "数据链路层",
            "date_published": "2021-11-12T10:17:54.000Z",
            "content_html": "<h2 id=\"数据链路层的功能\"><a class=\"anchor\" href=\"#数据链路层的功能\">#</a> 数据链路层的功能</h2>\n<h4 id=\"概要\"><a class=\"anchor\" href=\"#概要\">#</a> 概要</h4>\n<p><strong>将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路</strong>。</p>\n<h4 id=\"为网络层提供的服务\"><a class=\"anchor\" href=\"#为网络层提供的服务\">#</a> 为网络层提供的服务</h4>\n<p>无确认的无连接服务：适用于实时通信或误码率低的通信信道。如：以太网。</p>\n<p>有确认的无连接服务：该服务适用于误码率较高的通信信道无线通信。</p>\n<p>有确认的面向连接服务：帧传翰过程分为三个阶段：<strong>数据链路、传输帧、释放数据链路</strong>，目的计算机对收到的每一帧都要给出确认，</p>\n<p><span class=\"label info\">没有无确认的面向连接服务</span></p>\n<h4 id=\"帧定界-帧同步与透明传输\"><a class=\"anchor\" href=\"#帧定界-帧同步与透明传输\">#</a> 帧定界、帧同步与透明传输</h4>\n<p><strong>帧定界</strong>：首部尾部的控制信息，它们的一个重要作用就是确定帧的界限。<br>\n<strong>帧同步</strong>：接收方应能从接受到的二进制比特流中区分出帧的起始和终止。<br>\n<strong>透明传输</strong>：采取有效的措施解决误认为 “传输结束” 而丢弃后面数据的问题。就是不管所传数据是什么样的比特组合，都应当能在链路上传送。</p>\n<h4 id=\"流量控制\"><a class=\"anchor\" href=\"#流量控制\">#</a> 流量控制</h4>\n<p><strong>问题引入</strong>：收发双方各自的工作速率和缓存空间的差异，出现发送方的发送能力大于接收方的接收能力的现象，如不对其进行流量控制就会导致数据丢失。<strong>流量控制</strong>就是通过控制发送方的发送速度，从而实现流量控制。</p>\n<p><span class=\"label info\">数据链路层控制相邻两点之间的流量，运输层控制源端到目的端的流量</span></p>\n<h4 id=\"差错控制\"><a class=\"anchor\" href=\"#差错控制\">#</a> 差错控制</h4>\n<p><strong>差错控制</strong>就是使发送方确定接收方是否正确收到由其发送的数据的方法。</p>\n<p>位错（数据中的某些位出现错误） CRC 循环冗余码（解决位错）</p>\n<p>帧错（帧的丢失、重复或时序等错误） 自动重传请求 ARQ（解决帧错）。</p>\n<ol start=\"3\">\n<li class=\"quiz\">数据链路层的协议不包括 {.gap} 。\n<ul class=\"options\">\n<li>定义数据格式</li>\n<li class=\"correct\">为终端节点隐藏物理传输的细节</li>\n<li>提供节点之间的可靠传输</li>\n<li>控制对物理传输介质的访问</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"组帧\"><a class=\"anchor\" href=\"#组帧\">#</a> 组帧</h2>\n<p><strong>字符计数法</strong>就是指在帧头部使用一个计数字段来标明帧内字符数</p>\n<p>该方法的缺点就是如果计数字段出错，收发双方将失去同步从而导致错误。</p>\n<p>计数值要加上自身的一位</p>\n<p><strong>字符填充法使用特定字符来定界一帧的开始和结束</strong>。例如：控制字符<strong> SOH</strong> 放在帧的最前面，表示帧的首部开始，控制字符<strong> EOT</strong> 表示帧的结束。当信息位出现特殊字符时可以在特殊字符前添加一个转义字符<strong> ESC</strong> 加以区分。</p>\n<p>复杂，不兼容</p>\n<p><strong>零比特填充的首尾标志法（目前常用）：使用一个特定的比特模式，即 01111110 来标志一帧的开始和结束</strong>。在发送信息时，遇到 5 个连续的 1 就自动在后面加 0。当收到信息时，遇到 5 个连续的 1 就自动在后面减 0。</p>\n<p>优点：零比特填充法很容易由硬件来实现，性能优于字符填充法。</p>\n<p><strong>违规编码法</strong>（目前常用）：在<strong>物理层进行比特编码时</strong>，曼彻斯特编码中比特 ”1&quot;编码成 “高－高 “ 电平，比特”0&quot; 编码成 “低－低 “ 电平（由于正常情况下不会出现这种情况，所以可以用这个办法来进行定界）</p>\n<h2 id=\"差错控制-2\"><a class=\"anchor\" href=\"#差错控制-2\">#</a> 差错控制</h2>\n<h3 id=\"检错编码\"><a class=\"anchor\" href=\"#检错编码\">#</a> 检错编码</h3>\n<h4 id=\"奇偶检验码\"><a class=\"anchor\" href=\"#奇偶检验码\">#</a> 奇偶检验码</h4>\n<p>奇偶校验码由 n-1 位数据和 1 位校验位组成，校验位用于调节发送信息中的 1 的个数是偶数还是奇数。</p>\n<h4 id=\"循环冗余码\"><a class=\"anchor\" href=\"#循环冗余码\">#</a> 循环冗余码</h4>\n<p><img data-src=\"image-20211112195334860.png\" alt=\"image-20211112195334860\"></p>\n<p><span class=\"rainbow\">除数最高位和最低位必须为 1</span></p>\n<p><span class=\"rainbow\">凡是接收端数据链路层接受的帧都没有差错</span></p>\n<p>CRC 有纠错功能，只是数据链路层仅使用它的检错功能</p>\n<h3 id=\"纠错编码\"><a class=\"anchor\" href=\"#纠错编码\">#</a> 纠错编码</h3>\n<p>在数据通信的过程中，有一个方法就是添加<strong>足够的冗余信息</strong>，使得接收方能够推理出发送方实际传送的比特串。<strong>常见的纠错编码就是海明码</strong>。</p>\n<p>（1）确定海明码的位数：<br>\n设 n 为有效信息的位数，k 为校验位的位数，则信息位 n 和校验位 k 应满足 n+k&lt;=2^k-1（若要检测两位错，则需再增加 1 位检验位，即 k+1 位）</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210216095428952.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>（2）确定校验位的分布<br>\n规定校验位在海明位号为 2^（i-1）位詈上，其余各位为信息位。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210216095543512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTgzMDEw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>（3）分组形成校验关系<br>\n被校验数据位的海明位号等于校验该数位的各校验位海明位号之和。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210216095731114.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>（4）校验位取值</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210216095920301.png#pic_center\" alt=\"在这里插入图片描述\">    校验位的值为对应组的所有位求异或。</p>\n<p>（5）海明码的校验原理<br>\n每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，构成 k 个校验方程：</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210216095935551.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<pre><code>若s3s2s1的值为000，则说明无措，否则说明有错，而且这个数就是错误的位号，如001，就说明第一位出错即H1出错。直接将该位取反就达到纠错的目的了\n</code></pre>\n<p><span class=\"rainbow\">海明码纠错 d 位，需要码距为 2d+1 的编码方案，检错 d 位，需要码距 d+1</span></p>\n<h2 id=\"流量控制和可靠传输\"><a class=\"anchor\" href=\"#流量控制和可靠传输\">#</a> 流量控制和可靠传输</h2>\n<p><strong>停止 — 等待流量控制基本原理</strong>：每次只允许发送一帧，然后就陷入等待接收方确认信息的过程中，如果接收方不反馈应答信号，那么发送方必须一致等待，因而传输效率很低。</p>\n<h3 id=\"滑动窗口\"><a class=\"anchor\" href=\"#滑动窗口\">#</a> 滑动窗口</h3>\n<p>发送窗口，接受窗口</p>\n<p><strong>滑动窗口机制特点</strong>：<br>\n1. 只有接收窗口向前滑动时，发送窗口才有可能向前滑动。<br>\n2. 接收窗口的大小为 1 时，可保证帧的有序接收。<br>\n3. 数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的。</p>\n<h3 id=\"单针滑动窗口与停止等待协议\"><a class=\"anchor\" href=\"#单针滑动窗口与停止等待协议\">#</a> 单针滑动窗口与停止 — 等待协议</h3>\n<p><strong>发送窗口和接收窗口为 1</strong></p>\n<p><strong>一种是接受时帧已经遭到破坏</strong>，解决方法是装备计时器</p>\n<p><strong>另一种是数据帧正确而确认帧被破坏</strong>。解决方法：发送方重传已被接受的数据帧，接收方接收到后丢弃，并重传一个确认帧。</p>\n<p><strong>帧缓冲区</strong>：设立目的是为了超时重发和判定重复帧的需要。帧缓冲区实现方法：发送端在发送完数据帧时，必须在其发送缓存中保留此数据帧的副本，这样才能在出差错时进行重传，只有在收到对方发来的确认帧 ACK 时，方可清除此副本。</p>\n<h3 id=\"多帧滑动窗口与后退n帧协议gbn\"><a class=\"anchor\" href=\"#多帧滑动窗口与后退n帧协议gbn\">#</a> 多帧滑动窗口与后退 N 帧协议（GBN）</h3>\n<p>发送窗口大于 1，接收窗口为 1</p>\n<p>接收方只会按序接收数据帧，而确认帧发送序列号最大的，按序到达的帧（累计确认，偶尔捎带确认）。</p>\n<p><strong>后退 N 帧协议</strong>：</p>\n<p><strong>优点</strong>：连续发送数据帧而提高了信道的利用率。</p>\n<p><strong>缺点</strong>：若信道的传输质量很差导致误码率较大时，后退 N 帧协议不一定优于停止 - 等待协议。</p>\n<p><span class=\"rainbow\">若采用 n 比特对帧编号，那发送窗口的尺寸最大值为 2^n-1，否则会造成接受方无法识别新帧和旧帧</span></p>\n<h3 id=\"多帧滑动窗口与选择重传协议sr\"><a class=\"anchor\" href=\"#多帧滑动窗口与选择重传协议sr\">#</a> 多帧滑动窗口与选择重传协议（SR）</h3>\n<p>发送窗口大于等于 1，接收窗口大于等于 1.</p>\n<p><strong>选择重传协议</strong>：每个发送缓冲区对应一个计时器，当计时器超时时，缓冲区的帧就会重传。接收方会设置具有相当容量的缓冲区来暂存那些未按需正确收到的帧。一旦接受方怀疑帧出错，就会发送否定帧 NAK 给发送方要求发送方对 NAK 中指定的帧进行重传。</p>\n<p>[接受窗口 + 发送窗口 &lt;=2^n</p>\n<p class=\"label info\">接收窗口 &lt;=2]</p>\n<p>优点：提高了信道的利用率。</p>\n<p>缺点：需要缓存空间来存储数据。</p>\n<p>[设发送周期（从开始发送数据到第一个确认帧为止）为 T，发送 L 比特数据，传输速率为 C，信道利用率 =(L/C)/T</p>\n<p>(要注意区分停止 - 等待和其他两个的区别，有坑)</p>\n<p class=\"label info\">信道吞吐量 = 信道利用率 * 发送速率]</p>\n<p><span class=\"label info\">确认帧是期望收到的下一个帧</span></p>\n<h2 id=\"介质访问控制\"><a class=\"anchor\" href=\"#介质访问控制\">#</a> 介质访问控制</h2>\n<h3 id=\"信道划分介质访问控制不会冲突静态划分\"><a class=\"anchor\" href=\"#信道划分介质访问控制不会冲突静态划分\">#</a> 信道划分介质访问控制（不会冲突）（静态划分）</h3>\n<p>网络负载重，信道效率高。。。</p>\n<p><strong>频分多路复用（FDM）</strong></p>\n<p>是一种将多路基带信号调制到不同频率载波上，再叠加形成一个复合信号的多路复用技术。充分利用了传输介质的带宽（<strong>所有子信道的带宽之和不能超过信道的总带宽</strong>），但是需要在相邻信道之间加入保护频带防止子信道相互干扰。</p>\n<p><strong>时分多路复用</strong> (TMD)</p>\n<p>是将一条物理通道按时间分成若干时间片，轮流地分配给多个信号使用。但是由于计算机数据的突发性，用户对子信道的利用率不高。<strong>统计时分多路复用</strong>（<strong>STDM</strong>）采用 STDM 帧，STDM 帧不固定分配时隙 ，而按需动态地分配时隙，提高了线路的利用率。</p>\n<p><span class=\"label info\">4 用户，TMD 每人最高速率 1，STDM 是 4</span></p>\n<p><span class=\"label info\">现在计算机网络更多使用 TDM 而非 FDM，因为 TDM 可用于数字传输</span></p>\n<p><strong>波分多路复用</strong>（WDM）</p>\n<p>在一根<strong>光纤</strong>中传输多种不同波长的<strong>光信号</strong>由于波长（频率）不同 ，各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p>\n<p><strong>码分多路复用</strong>：（CDM）</p>\n<p>使用不同的编码来区分各路原始信号的一种复用方式，与 FDM 与 TDM 不同，它既共享信道的频率，又共享时间。<br>\n码分多址（CDMA）：每个比特时间划分为 m 个短的时间槽，称为码片。通常 m 的值为 64 或者 128，每个站点被指派一个唯一的码片序列，发送 1 时，站点发送码片序列，发送 0 时，站点发送码片序列的反码。当两个或多个站点发送数据时，各路数据在信道中线性相加，为从信道中分离出各路信号，各个站点的码片序列<strong>相互正交</strong>，从而从信道中分离出各路信号。</p>\n<h3 id=\"随机访问介质访问控制会冲突\"><a class=\"anchor\" href=\"#随机访问介质访问控制会冲突\">#</a> 随机访问介质访问控制（会冲突）</h3>\n<p>所有用户能根据自己的意愿随机地发送信息，占用信道全部速率。</p>\n<p>网络负载重时，冲突开销高</p>\n<p>网络负载轻，信道利用率高</p>\n<h4 id=\"aloha协议\"><a class=\"anchor\" href=\"#aloha协议\">#</a> ALOHA 协议</h4>\n<p><strong>纯 ALOHA 协议</strong>：当网络中的任何一个站点需要发送数据时，可以不进行任何检测就发送数据。在一段时间未收到确认时，南无该站点就认为传输过程中发生了冲突，发送站随机等待一段时间后再发送数据，直至发送成功。缺陷：数据碰撞的概率较大，所以网络的吞吐量很低。<br>\n<strong>时隙 ALOHA 协议</strong>：在纯 ALOHA 协议的基础上将所有站的时间同步起来，将时间划分为一段段等长的时隙，规定只能在每个时隙开始时才能发送一个帧。优点：避免了用户发送数据的随意性，减少了数据产生冲突的可能性，提高了信道的利用率。缺陷：碰撞概率还是很大。</p>\n<h4 id=\"csma协议\"><a class=\"anchor\" href=\"#csma协议\">#</a> CSMA 协议</h4>\n<p><strong>1 - 坚持 CSMA 协议</strong>：一个节点想要发送数据首先侦听信道。如果信道空闲，那么立即发送数据。如果信道忙，那么等待，同时继续侦听，直至信道空闲。如果发生冲突，那么随机等待一段时间再重新开始侦听。缺陷：传播延迟对协议的性能影响较大且存在碰撞现象。<br>\n<strong>非坚持 CSMA 协议</strong>：一个节点想要发送数据首先侦听信道。如果信道空闲，那么立即发送数据。如果信道忙，那么放弃侦听，等待一个随机的时间后再重复该过程。优点：降低了多个结点等待信道空闲后同时发送数据导致冲突的概率。缺陷：增加数据在网络中的延迟时间。<br>\n<strong>p - 坚持 CSMA 协议</strong>：一个节点想要发送数据首先侦听信道。如果信道忙，就持续侦听，直至信道空闲。如果信道空闲，那么以概率 p 发送据，以 1-p 概率推迟到下一个时隙。优点：降低了冲突概率同时减少了时间延迟。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/2021021709142685.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"csmacd协议重点\"><a class=\"anchor\" href=\"#csmacd协议重点\">#</a> CSMA/CD 协议（<em>重点</em>）</h4>\n<p>载波监听多路访问 / 碰撞检测（CSMA/CD）中</p>\n<p>+++<strong> 载波帧听</strong>：</p>\n<p>发送前先侦听，即每个站在发送数据之前先要检测一下总线是否有其他站点正在发送数据，若有，则暂时不发送数据，等待信道变为空闲时，再发送。</p>\n<p>+++</p>\n<p>+++<strong> 碰撞检测</strong>：就是边发送边侦听，即适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站点是否也在发送数据</p>\n<p>+++</p>\n<p>（先听后发，边听边发，冲突停发，随机重发）</p>\n<p><strong>CSMA/CD 协议，适用于总线形网络或半双工网络环境，采用 CSMA/CD 协议的以太网只能进行半双工通信</strong></p>\n<p><img data-src=\"image-20211113214055854.png\" alt=\"image-20211113214055854\"></p>\n<p><strong>争用期</strong>指以太网端到端的<strong>往返时间</strong></p>\n<p>最小帧长＝总线传播时延＊数据传输率＊2（即争用期乘以数据传输速率）</p>\n<p><span class=\"rainbow\">以太网规定的最短帧长为 64B</span></p>\n<p>CSMA/CD 协议使用<strong>二进制指数退避算法</strong>解决碰撞，其算法如下：<br>\n（1）确定基本退避时间，一般为争用期（两倍的总线端到端传播时延）。<br>\n（2）定义参数 k，它等于重传次数，但 k 不超过 10，即 k=min [重传次数，10]。<br>\n（3）从离散的整数集合 [0,1,2,3,……2^<strong>k-1</strong>] 中随机取一个数 r，重传所需要的退避时间就是 r * 争用期。<br>\n（4）当重传次数达<strong> 16</strong> 次仍不能成功，说明网络太拥挤，抛弃此帧，向高层报告出错。<br>\n使用二进制指数退避算法可使重传需要推迟的平均时间随重传次数的增大而增大，降低发生碰撞的概率，有利于整个系统的稳定。</p>\n<p><span class=\"rainbow\">当信号传播延迟趋近于 0 时，信道利用率趋近 100%</span></p>\n<h4 id=\"csmaca协议只能避免不能检测\"><a class=\"anchor\" href=\"#csmaca协议只能避免不能检测\">#</a> CSMA/CA 协议 (只能避免，不能检测)</h4>\n<details><summary>**CSMA/CD协议适用于于使用有线连接的局域网（无线网络不能使用该协议）**</summary><div>\n<div class=\"note info\">\n<p>发送前侦听，边发送边侦听，一旦出现碰撞马上停止发送。在无线局域网存在以下两个问题：由于<strong>接收信号的强度往往会远小于发送信号的强度</strong>，且在无线介质上信号强度的动态变化范围很大。而且在无线通信中，并非所有的站点都能够听见对方，存在 <strong>“隐蔽站” 问题</strong>。</p>\n</div>\n<p>**RTS/CTS 帧（可选） **：可选的碰撞避免机制，主要用于解决无线网中的隐蔽站问题。</p>\n<p>实现碰撞避免机制：<strong>预约信道</strong>：发送方在发送数据的同时向其他站点通知自己传输数据需要的时间长度，让其他站点在这段时间内不发送数据，避免碰撞。<strong>ACK 帧</strong>：所有站点在正确接收到发给自己的数据帧（除广播帧和组播帧）后，都需要向发送方发回一个 ACK 帧，如果 ACK 帧接收失败，不采取任何行动。在规定的时间内如果未收到 ACK 帧，那么认为发送失败，此时进行该数据帧的重发，直到收到 ACK 帧或达到规定重发次数为止。同时 CSMA/CA 协议也是采用<strong>二进制指数退避算法</strong>解决碰撞问题的。</p>\n<p><strong>帧间间隔</strong>：每次发完帧要等一会，<strong>SIFS（短）</strong>：用于 ACK,CTS, 数据帧。<strong>DIFS</strong>（长）：用于异步帧竞争访问的延时</p>\n<p><img data-src=\"image-20211113214036389.png\" alt=\"image-20211113214036389\"></p>\n<h4 id=\"csmacd与csmaca区别\"><a class=\"anchor\" href=\"#csmacd与csmaca区别\">#</a> CSMA/CD 与 CSMA/CA 区别</h4>\n<pre><code>（1）CSMA/CD可以检测冲突，但无法避免；CSMA/CA发送包的同时不能检测到信道上有无冲突。\n（2）CSMA/CD用于总线形以太网CSMA/CA用于无线局域网802.1 la/b/g/n等。\n（3）CSMA/CD通过电缆中的电压变化来检测；而CSMA/CA采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式。\n</code></pre>\n<h3 id=\"轮询访问介质访问控制令牌传递协议不会冲突\"><a class=\"anchor\" href=\"#轮询访问介质访问控制令牌传递协议不会冲突\">#</a> 轮询访问介质访问控制：令牌传递协议（不会冲突）</h3>\n<p>应用于令牌环网<span class=\"label info\">物理上星形网，逻辑上环形网</span></p>\n<p>通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道的分配令牌在固定次序中转圈，拿到令牌的结点就可以发送数据，<strong>而不会产生冲突</strong>。</p>\n<p>适用于负载很高的广播信道。</p>\n<h2 id=\"局域网选择题\"><a class=\"anchor\" href=\"#局域网选择题\">#</a> 局域网（选择题）</h2>\n<h3 id=\"基本概念\"><a class=\"anchor\" href=\"#基本概念\">#</a> 基本概念</h3>\n<p><strong>局域网</strong>（LAN）是指在一个较小的地理范围内，将各种计算机外部设备和数据库系统等通过<strong>双绞线、同轴电缆</strong>等连接介质互相连接起来，组成资源和信息共享的计算机互联网络。<strong>局域网的主要特点</strong>如下：</p>\n<p>（1）为一个单元所拥有，且地理范围和站点数目均有限。<br>\n（2）所有站点共享较高的总带宽。<br>\n（3）较低的时延和较低的误码率。<br>\n（4）各站为平等关系而非主从关系。<br>\n（5）能进行广播和组播。</p>\n<p><strong>局域网拓扑结构及其实现</strong><br>\n局域网的特性主要由三个要素决定：<strong>拓扑结构、传输介质和介质访问控制方式</strong>，最重要的是介质访问控制方式，它决定着局域网的技术特性。<br>\n常见的局域网拓扑结构有星形结构、环形结构和总线形结构以及星星和总线形结合的复合型结构。传输介质有双绞线、铜缆和光纤。双绞线为局域网的主流传输介质。总线形局域网中的介质访问控制方法有 CSMA/CD、令牌总线。而令牌环是环形局域网的介质访问控制方法。局域网拓扑实现：<br>\n（1）<strong>以太网 IEEE802.3</strong>：逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构。<br>\n（2）<strong>令牌环 IEEE802.5</strong>：逻辑拓扑是环形结构，物理拓扑是星形结构。<br>\n（3）<strong>FDDI IEEE802.8</strong>（光纤分部数字接口）：逻辑拓扑是环形结构，物理拓扑是双环结构。</p>\n<hr>\n<p>IEEE802 标准定义局域网参考模型只对应于 OSI 参考模型的数据链路层和物理层。并将数据链路层拆分为逻辑链路控制子层和媒体介入控制子层。</p>\n<p><strong>逻辑链路控制 (LLC) 子层</strong>：向网络层提供无确认无连接、面向连接、带确认无连接、高速传送 4 种不同的连接服务类型。<br>\n<strong>媒体接入控制 (MAC) 子层</strong>：向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问接口，主要功能包括：组帧和拆卸帧、比特传输差错检测和透明传输。</p>\n<h3 id=\"以太网与ieee-8023\"><a class=\"anchor\" href=\"#以太网与ieee-8023\">#</a> 以太网与 IEEE 802.3</h3>\n<h4 id=\"以太网基本概念\"><a class=\"anchor\" href=\"#以太网基本概念\">#</a> 以太网基本概念</h4>\n<p>802.3 局域网简称为<strong>以太网</strong>。</p>\n<p>CSMA/CD</p>\n<p>以太网采用两项措施简化通信：（1）采用<strong>无连接的工作方式</strong>，提供不可靠的服务，实现无差错接受，对差错的纠正由高层完成。（2）发送数据使用<strong>曼彻斯特编码</strong>的信号。</p>\n<p>图标重要</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210219074142601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzOTgzMDEw,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>计算机与外界局域网的连接是通过主机箱内插入的一块网络接口板（又称<strong>网络适配器或者网络接口卡</strong>）实现的。网卡的主要功能有：实现局域网传输介质之间的物理连接和电信号匹配，实现帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存功能。</p>\n<h4 id=\"以太网的mac帧\"><a class=\"anchor\" href=\"#以太网的mac帧\">#</a> 以太网的 MAC 帧</h4>\n<p>每块网卡在出厂时都有一个唯一的代码，称为<strong>介质访问控制地址</strong>（MAC 地址，前 24 位代表厂家，后 24 厂家自己规定）</p>\n<p>由于总线上是<strong>广播通信</strong>，因此网卡从网络上每收到一个 MAC 帧，首先要用硬件检查 MAC 帧中的 MAC 地址。</p>\n<p><span class=\"rainbow\">同一局域网有两个相同的 MAC 地址，在网络上这两个设备都不能正确通信</span></p>\n<p>MAC 帧结构组成如下：<br>\n地址：通常使用 6 字节 (48bit) 地址（目的地址，源地址总共 12 字节）<br>\n类型：2 字节，指出数据域中携带的数据应交给哪个协议实体处理<br>\n数据：46-1500 字节，包含高层的协议消息。由于 CSMNCD 算法的限制，以太网帧必须满足品小长度要求 64 字节，数据较少时必须加以填充 (0-46 字节）<br>\n填充：0-46 字节，当帧长太短时填充帧，使之达到 64 字节的最小长度<br>\n校验码 (FCS) ：4 字节，采用 CRC 循环冗余码</p>\n<h3 id=\"高速以太网\"><a class=\"anchor\" href=\"#高速以太网\">#</a> 高速以太网</h3>\n<p><strong>100BASE-T 以太网</strong>：适用于在双绞线上传送 100Mb/s<strong> 基带信号</strong>的星形拓扑结构以太网，使用 CSMA/CD 协议（半双工），支持全双工方式，支持半双工方式。<br>\n<strong>吉比特以太网</strong>：在 1Gb/s 下，用全双工和半双工两种方式工作。在半双工方式下，使用 CSMA/CD 协议。<br>\n<strong>10 吉比特以太网</strong>：使用光纤作为传输媒体，只工作在全双工方式，因此没有争用间题，也不使用 CSMA/CD 协议。<br>\n<span class=\"rainbow\">快速以太网采用，保持最短帧长不变，而将最大电缆长度减少到 100m 的方法，时以太网的数据传输速率提高至 100Mb/s</span></p>\n<h3 id=\"ieee-80211\"><a class=\"anchor\" href=\"#ieee-80211\">#</a> IEEE 802.11</h3>\n<p><img data-src=\"https://img-blog.csdnimg.cn/2020082123355756.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<p>地址 1 : RA 接收端，接收端 基站 地址；<br>\n 地址 2 : TA 发送端，发送端 基站 地址；<br>\n 地址 3 : DA 目的地址，目标主机的 MAC 地址；<br>\n 地址 4 : SA 源地址，发送端的 MAC 地址；</p>\n<h5 id=\"有固定基础设施无线局域网\"><a class=\"anchor\" href=\"#有固定基础设施无线局域网\">#</a> 有固定基础设施无线局域网</h5>\n<p>802.11 标准规定无线局域网的最小构件是基本服务集 (BSS)，<strong>一个基本服务集包括一个基站和若干移动站</strong>。所有的站在本 BSS 内都可以直接通信，但在与本 BSS 外的站通信时都要通过本 BSS 的基站。</p>\n<h5 id=\"无固定基础设施无线局域网自组织网络\"><a class=\"anchor\" href=\"#无固定基础设施无线局域网自组织网络\">#</a> 无固定基础设施无线局域网自组织网络</h5>\n<p>另一种无线局域网是无固定基础设施的无线局域网，又称自组织网络。由一些<strong>平等状态移动站</strong>相互通信组成的临时网络。各结点之间地位平等，中间结点都为转发结点，这些结点都具有路由器功能。移动自组织网络把移动性扩展到无线领域中的自治系统，移动自组织网络把移动性扩展到无线领域中的自治系统。</p>\n<h3 id=\"广域网\"><a class=\"anchor\" href=\"#广域网\">#</a> 广域网</h3>\n<p>其通信子网主要采用<strong>分组交换</strong>技术</p>\n<p>局域网可以通过广域网与另一个相隔很远的局域网通信</p>\n<p><img data-src=\"image-20211113214015721.png\" alt=\"image-20211113214015721\"></p>\n<h4 id=\"ppp协议\"><a class=\"anchor\" href=\"#ppp协议\">#</a> ppp 协议</h4>\n<p><strong>PPP 协议</strong>是使用<strong>串行线路通信</strong>的<strong>面向字节</strong>的协议，该协议应用在之间连接两个结点的链路上。PPP 协议是在 SLIP 协议的基础上发展而来的，它既可以在一部线路上传输，又可在同步线路上使用，不仅用于 Modem 链路，也可用于租用的路由器到路由器的线路。</p>\n<p>PPP 协议由三部分组成：<br>\n(1)<strong> 链路控制协议 (LCP)</strong>：一种扩展链路控制协议，用于建立配置、测试和管理数据链路。<br>\n(2)<strong> 网络控制协议 （NCP）</strong>:PPP 协议允许同时采用多种网络层协议，每个网络层协议都需要用一个相应的 NCP 来配置，为网络层建立和配置逻辑连接。<br>\n(3) 一个将 IP 数据包封装到串行链路的方法。</p>\n<p><strong>PPP 协议注意事项</strong><br>\n PPP 协议只支持<strong>全双工链路</strong>。不采用 CSMA/CD，所以信息段占的字节是 0--1500B<br>\nPPP 协议提供差错检测但不提供纠错功能， 只保证无差错接收（通过硬件进行 CRC 校验）。<br>\nPPP 协议是不可靠的传输协议，因此也不使用序号和确认机制<br>\n PPP 协议仅支持点对点的链路通信，<strong>不支持多点线路</strong>。<br>\nPPP 协议两端可以运行<strong>不同的网络层协议</strong>，但仍然可以使用同一个 PPP 通信。<br>\nPPP 协议是面向字节，的当信息字段出现和标志字段一致的比特组合时 PPP 有两种处理方法：PPP 用在异步线路（默认），则采用字节填充法。PPP 用在同步线路，则协议规定采用硬件来完成比特填充法。</p>\n<h2 id=\"链路层设备\"><a class=\"anchor\" href=\"#链路层设备\">#</a> 链路层设备</h2>\n<h3 id=\"局域网交换机及其工作原理\"><a class=\"anchor\" href=\"#局域网交换机及其工作原理\">#</a> 局域网交换机及其工作原理</h3>\n<p>局域网交换机又称以太网交换机</p>\n<p>多端口的网桥</p>\n<p><strong>局域网交换机工作原理</strong>：检测从以太端口来的数据帧的源和目的地的 MAC（介质访间层）地址，然后与系统内部的动态查找表进行比较若数据帧的 MAC 地址 不在查找表中，则将该地址加入查找表，并将数据帧发送给相应的目的端口。</p>\n<p><strong>局域网交换机特点</strong>：工作在<strong>全双工方式</strong>，碰撞地传输数据，转发表也是通过自学习算法自动地逐渐建立起来的，使用了专用的交换结构芯片，因此交换速率较高<strong>独占传输媒体的带宽</strong>。</p>\n<p><strong>局域网交换机优点</strong>：对工作站是透明的，管理开销低廉，简化了 网络结点的增加、移动和网络变化的操作。方便地实现虚拟局域网 (VLAN) VLAN 可以<strong>隔离冲突域，而且可以隔离广播域</strong>。</p>\n<h3 id=\"局域网交换机交换方式\"><a class=\"anchor\" href=\"#局域网交换机交换方式\">#</a> 局域网交换机交换方式</h3>\n<p><strong>直通式交换机</strong>：只检查帧的目的地址，数据帧可以马上就被传输出去。优点：速度快。缺点：缺乏智能性和安全性， 也无法支持具有不同速率的端口的交换。</p>\n<p><strong>存储转发式交换机</strong>：先将接收到的帧缓存，然后并检查数据是否正确，如果帧正确就发送出去。如果发现帧有错，那么就将其丢弃。优点：可靠性 高，并能支持不同速率端口间的转换。缺点：延迟较大。</p>\n<p><img data-src=\"image-20211113221934357.png\" alt=\"image-20211113221934357\"></p>\n<hr>\n<p><span class=\"rainbow\">从互联网的角度看，广域网和局域网是平等的</span></p>\n<p><img data-src=\"image-20211114095405825.png\" alt=\"image-20211114095405825\"></p>\n<p><img data-src=\"image-20211114095503401.png\" alt=\"image-20211114095503401\"></p>\n</div></details>\n",
            "tags": [
                "考研",
                "计算机网络"
            ]
        },
        {
            "id": "http://example.com/2021/11/12/%E6%94%BF%E6%B2%BB%E9%80%89%E6%8B%A9%E9%A2%98%E9%94%99%E9%A2%98/",
            "url": "http://example.com/2021/11/12/%E6%94%BF%E6%B2%BB%E9%80%89%E6%8B%A9%E9%A2%98%E9%94%99%E9%A2%98/",
            "title": "政治选择题错题",
            "date_published": "2021-11-12T09:36:25.000Z",
            "content_html": "<p>在内容与形式的矛盾运动中，内容较为易变，形式则较为稳定。</p>\n<p>可能有两种形式，即现实的可能和抽象（非现实）的可能，二者的区别在于，现实中的根据和 条件是否充分。而可能性和不可能性的区别在于，在现实中有无根据和条件。这里要注意区别抽象的可能与不可能。</p>\n<p>否承认对立统一学说是唯物辩证法和形而上学对立的实质。</p>\n<p>唯物辩证法所说的矛盾是辩证矛盾（事物本身所固有的对立统一关系），而逻辑矛盾是指人们思维过程中由于违反形式逻辑规则所造成的自相矛盾。</p>\n<p>主观辩证法是客观辩证法的反映。它们不是决定与被</p>\n<p>决定的关系，也不是源与流的关系。</p>\n<h3 id=\"多选\"><a class=\"anchor\" href=\"#多选\">#</a> 多选</h3>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211114131356343.png\" alt=\"image-20211114131356343\"></p>\n<p>ABD</p>\n<h3 id=\"单选\"><a class=\"anchor\" href=\"#单选\">#</a> 单选</h3>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211114131520289.png\" alt=\"image-20211114131520289\"></p>\n<p>D</p>\n",
            "tags": [
                "考研",
                "政治"
            ]
        },
        {
            "id": "http://example.com/2021/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%8F%99/",
            "url": "http://example.com/2021/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%8F%99/",
            "title": "计算机网络概叙",
            "date_published": "2021-11-11T06:17:17.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://example.com/2021/11/10/%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98/",
            "url": "http://example.com/2021/11/10/%E6%95%B0%E5%AD%A6%E7%9C%9F%E9%A2%98/",
            "title": "数学真题",
            "date_published": "2021-11-10T11:11:16.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://example.com/2021/11/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/",
            "url": "http://example.com/2021/11/08/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/",
            "title": "内存管理",
            "date_published": "2021-11-08T15:47:10.000Z",
            "content_html": "<h2 id=\"内存管理概念\"><a class=\"anchor\" href=\"#内存管理概念\">#</a> 内存管理概念</h2>\n<h4 id=\"内存管理的功能\"><a class=\"anchor\" href=\"#内存管理的功能\">#</a> 内存管理的功能</h4>\n<p>（1）内存空间的分配与回收。<br>\n（2）地址转换。<br>\n（3）内存空间的扩充。<br>\n（4）存储保护。</p>\n<p>（1）编译。由编译程序将用户源代码变异成若干目标模块。<br>\n（2）链接（<strong>生成逻辑地址</strong>）。由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完成的装入模块。<br>\n（3）装入。由装入程序将装入模块装入内存中运行。<br>\n程序的链接有以下三种方式：<br>\n（1）静态链接。<br>\n（2）装入时动态链接。<br>\n（3）运行时动态链接。其优点是便于修改和更新，便于实现对目标模块的共享。<br>\n内存的装入模块在装入内存时，同样有以下三种方式：<br>\n（1）绝对装入。只适用于单道程序环境。<br>\n（2）可重定位装入（静态重定位）。<br>\n静态重定位的特点是：一个作业装入内存时，必须给它分配要求的全部内存空间，若没有足够的内存，则不能装入该作业，此外，作业一旦进入内存，整个运行期间就不能在内存中移动，也不能再申请内存空间。<br>\n（3）动态运行时装入。也称动态重定位。<br>\n动态重定位特点：需要重定位寄存器，可以将程序分配到不连续的存储区中，便于程序段的共享，可以向用户提供更大的地址空间（地址空间大于存储空间）。</p>\n<h4 id=\"内存保护\"><a class=\"anchor\" href=\"#内存保护\">#</a> 内存保护</h4>\n<p>设置一对上、下限寄存器</p>\n<p>重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）</p>\n<h4 id=\"连续分配管理\"><a class=\"anchor\" href=\"#连续分配管理\">#</a> 连续分配管理</h4>\n<h5 id=\"单一连续分配\"><a class=\"anchor\" href=\"#单一连续分配\">#</a> 单一连续分配</h5>\n<p>内存分为系统区和用户区</p>\n<p>优点是简单、无外部碎片，可以采用覆盖技术，不需要额外的技术支持。缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率低。</p>\n<h5 id=\"固定分区分配\"><a class=\"anchor\" href=\"#固定分区分配\">#</a> 固定分区分配</h5>\n<p>适用于多道程序的存储，无外部碎片；</p>\n<p>主存利用率第，有内部碎片，而且可能太大，放不进去</p>\n<h5 id=\"动态分区分配\"><a class=\"anchor\" href=\"#动态分区分配\">#</a> 动态分区分配</h5>\n<p>1）首次适用算法：最简单，最快，最好<br>\n（2）最佳适应算法：性能差，会产生很多小内部碎片<br>\n（3）最坏适应算法：性能差，很容易导致大内存块没了<br>\n（4）邻近适应算法：又称循环首次适应算法，性能比首次适应算法差</p>\n<h4 id=\"非连续分配管理\"><a class=\"anchor\" href=\"#非连续分配管理\">#</a> 非连续分配管理</h4>\n",
            "tags": [
                "考研",
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/2021/11/04/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/",
            "url": "http://example.com/2021/11/04/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/",
            "title": "进程管理",
            "date_published": "2021-11-04T15:06:40.000Z",
            "content_html": "<h2 id=\"进程与线程\"><a class=\"anchor\" href=\"#进程与线程\">#</a> 进程与线程</h2>\n<h5 id=\"进程的概念与特征\"><a class=\"anchor\" href=\"#进程的概念与特征\">#</a> 进程的概念与特征</h5>\n<p>进程实现了操作系统的 并发性和共享性</p>\n<p>进程映像：程序段，数据段，PCB</p>\n<p><span class=\"label primary\">创建进程实质上是创建 PCB</span></p>\n<p><span class=\"label info\">进程是程序在数据集上的运行过程</span></p>\n<p>进程特征：动态，并发，独立，异步，结构性</p>\n<h5 id=\"进程的状态与转换\"><a class=\"anchor\" href=\"#进程的状态与转换\">#</a> 进程的状态与转换</h5>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211104232451442.png\" alt=\"image-20211104232451442\"></p>\n<p><span class=\"label warning\">I/O 请求应改为事件等待，因为还有资源等待</span></p>\n<p>每个状态主要是看 cpu 与其他资源是否齐全</p>\n<p>运行态 -&gt; 阻塞态（主动）</p>\n<p>阻塞态 -&gt; 就绪态（被动）</p>\n<h5 id=\"进程控制\"><a class=\"anchor\" href=\"#进程控制\">#</a> 进程控制</h5>\n<p><span class=\"label primary\">关中断，开中断实现原语的一气呵成</span></p>\n<p>一般把进程控制用的程序段称为原语</p>\n<p>用户 登录系统，作业调度，系统提供服务，用户程序的应用请求都会引起进程的创建</p>\n<p><span class=\"label primary\">PCB 申请失败则进程创建失败，若资源不足，不是创建失败，而是处于阻塞态</span></p>\n<p>进程的终止：正常结束，异常结束，外界干预</p>\n<p>对于普通的进程而言，其创建，撤销及要求由系统设备完成的 I/O 操作，都是利用系统调用进入内核，再由内核程序处理</p>\n<p>进程切换要保存处机上下文（程序计数器和其他寄存器）</p>\n<p><span class=\"label warning\">注意进程切换和处理机模式切换时不同的</span></p>\n<p>::info</p>\n<p>调度和切换的区别：调度是决策行为，切换是执行行为</p>\n<p>::</p>\n<h5 id=\"进程的组织\"><a class=\"anchor\" href=\"#进程的组织\">#</a> 进程的组织</h5>\n<p>进程控制块：</p>\n<p>​\t进程描述信息：进程标识符，用户标识符</p>\n<p>​\t进程管理信息：进程状态，优先级，首地址等</p>\n<p>​\t资源分配清单：代码段制作，数据段指针，堆栈段指针</p>\n<p>​\t处理及相关信息：各寄存器</p>\n<p>PCB 组织方式：链接方式，索引方式</p>\n<h5 id=\"进程的通信\"><a class=\"anchor\" href=\"#进程的通信\">#</a> 进程的通信</h5>\n<p>PV 操作是低级通信方式</p>\n<p>共享存储：低级方式的共享基于数据结构的共享，高级方式的共享基于存储区的共享</p>\n<p>消息传递：直接通信方式（挂在消息队列上），间接通信方式（放在邮箱）</p>\n<p>管道通信：共享文件（pipe 文件或管道）</p>\n<p><span class=\"label info\">半双工通信，从管道读取数据时一次性操作，数据一旦被读取，就被抛弃</span></p>\n<h5 id=\"线程概念和多线程模型\"><a class=\"anchor\" href=\"#线程概念和多线程模型\">#</a> 线程概念和多线程模型</h5>\n<p>线程 ：轻量级进程，是一个基本的 cpu 执行单元，也是程序执行流的最小单元，由线程 id，程序计数器，寄存器集合，堆栈组成</p>\n<p>线程是独立调度的基本单位，进程是资源调度的基本单位</p>\n<p>线程可提高系统的并发性</p>\n<p>线程切换比进程切换的开销更小</p>\n<p>进程通信需要同步互斥手段辅佐，线程可直接读写进程数据段进行通信</p>\n<p><span class=\"label info\">用户级线程：线程管理工作都由应用系统完成，应用程序可以通过线程库设计成多线程</span></p>\n<p><span class=\"label info\">内核级线程：线程管理工作都由内核完成</span></p>\n<p>多对一模型：效率高，各线程不能并行，一旦阻塞整个进程会被阻塞</p>\n<p>一对一模型：并发能力强，用户态和内核态的切换开销大 <span class=\"rainbow\">操作系统为每个用户级线程建立一个线程控制块</span></p>\n<p>多对多模型</p>\n<hr>\n<p><span class=\"rainbow\">2 进制代码和常量放在正文段，动态分配的存储区在数据堆段，临时使用的变量在数据栈段</span></p>\n<p><span class=\"rainbow\">同一进程或不同进程的线程都能并发执行</span></p>\n<p><span class=\"rainbow\">父进程与子进程不共享虚拟地址空间</span></p>\n<ol start=\"3\">\n<li class=\"quiz\">系统动态 DLL 库中的系统线程，被不同的进程调用，它们是 [] 的进程 {.gap} 。\n<ul class=\"options\">\n<li>不同</li>\n<li class=\"correct\">相同</li>\n<li>可能相同，不同</li>\n<li>不能被调用</li>\n</ul>\n</li>\n<li class=\"quiz\">以下描述中，不是多线程系统的特长的是<span class=\"gap\"></span> 。\n<ul class=\"options\">\n<li>利用线程并行的执行矩阵乘法运算</li>\n<li class=\"correct\">键盘驱动程序为每个正在运行的应用配备一个线程，用以响应键盘输入</li>\n<li>web 服务器利用线程响应 HTTP 请求</li>\n<li>基于 GUI 的调式程序用不同的线程分别处理用户输入</li>\n</ul>\n</li>\n<li class=\"quiz\">以下关于线程的描述错误的是<span class=\"gap\"></span> 。\n<ul class=\"options\">\n<li>内核级线程的调度由操作系统来完成</li>\n<li class=\"correct\">操作系统为每个用户级线程创建一个线程控制块</li>\n<li>用户级线程间的切换比内核级切换效率高</li>\n<li>用户级线程可以在不支持内核级线程的操作系统上实现</li>\n</ul>\n</li>\n<li class=\"quiz\">以下关于管道通信的描述正确的是<span class=\"gap\"></span> 。\n<ul class=\"options\">\n<li>一个管道可以实现双向数据传输</li>\n<li class=\"correct\">进程堆管道进行读操作和写操作都有可能被阻塞</li>\n<li>管道容量只受到磁盘容量大小限制</li>\n<li>一个管道只能由一个读进程或一个写进程对其操作</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"处理机调度\"><a class=\"anchor\" href=\"#处理机调度\">#</a> 处理机调度</h2>\n<h5 id=\"调度的概念\"><a class=\"anchor\" href=\"#调度的概念\">#</a> 调度的概念</h5>\n<p>作业调度 （高级调度）：每个作业只调入调出一次  次数少</p>\n<p>内存调度（中级调度） ：进程进入挂起态（提高内存利用率和系统吞吐量） 次数中</p>\n<p>进程调度（低级调度） ：次数多</p>\n<h5 id=\"调度的时机\"><a class=\"anchor\" href=\"#调度的时机\">#</a> 调度的时机</h5>\n<p>不能进行进程调度的情况</p>\n<p>1. 在处理中断的过程中</p>\n<p>2. 进程在操作系统内核临界区</p>\n<p>3. 其他需要完全屏蔽中断的原子操作过程中</p>\n<p><span class=\"rainbow\">进程处于临界区可以进行处理机调度</span></p>\n<h5 id=\"进程调度方式\"><a class=\"anchor\" href=\"#进程调度方式\">#</a> 进程调度方式</h5>\n<p>非剥夺式（适用于大多批处理系统，不适合分时系统和实时系统）</p>\n<p>剥夺式</p>\n<h5 id=\"调度的性能\"><a class=\"anchor\" href=\"#调度的性能\">#</a> 调度的性能</h5>\n<p>cpu 利用率</p>\n<p>系统吞吐量：单位时间的作业完成数</p>\n<p>周转时间：作业完成时间 - 作业提交时间</p>\n<p>带权周转时间：作业周转时间 / 作业运行时间</p>\n<p>等待时间</p>\n<p>响应时间</p>\n<h5 id=\"调度算法\"><a class=\"anchor\" href=\"#调度算法\">#</a> 调度算法</h5>\n<p>先来先服务（FCFS）：算法简单，但是效率低，对长作业比较有利，但对短作业不利，有利于 CPU 繁忙型作业，不利于 I/O 繁忙型作业。</p>\n<p>短作业优先（SJF）（可抢，可不抢）：1）对长作业不利，造成<strong>饥饿现象</strong>（2）没有考虑作业的紧迫性，因而不能保证紧迫性作业会被及时处理。（3）作业长短是由用户提供的预估时间而定的，因而无法做到真正的短作业优先。</p>\n<p><span class=\"rainbow\">在所有进程都几乎同时到达或者是抢占式时，平均等待时间和周转时间最小</span></p>\n<p>优先级调度算法（可抢，可不抢）<strong>饥饿</strong>：</p>\n<p>1. 系统进程 &gt; 用户进程<br>\n 2. 交互型进程 &gt; 非交互型进程<br>\n 3.I/O 进程 &gt; 计算型进程（CPU 繁忙型）</p>\n<p>高响应比优先（非抢）： <strong>响应比 =（等待时间 + 要求服务时间）/ 要求服务时间</strong></p>\n<p>时间片轮转（RR）(抢占式算法): 默认新到达的进程先进入队列，刚完成时间片的进程后进入队列</p>\n<p>多级反馈队列调度（抢占）：</p>\n<p>（1）终端型作业用户，短作业优先。<br>\n（2）短批处理作业用户，周转时间短。<br>\n（3）长批处理作业用户：不会长期得不到处理 **（但是会导致饥饿）**。</p>\n<hr>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211106231028476.png\" alt=\"image-20211106231028476\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211106231047537.png\" alt=\"image-20211106231047537\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211106231123597.png\" alt=\"image-20211106231123597\"></p>\n<h2 id=\"进程同步\"><a class=\"anchor\" href=\"#进程同步\">#</a> 进程同步</h2>\n<h4 id=\"进程同步的概念\"><a class=\"anchor\" href=\"#进程同步的概念\">#</a> 进程同步的概念</h4>\n<p>（1）进入区：进程是否可以进入临界区，若能进入临界区则设置正在访问临界区的标志。<br>\n（2）临界区：可以访问临界资源的代码。<br>\n（3）退出区：将正在访问临界区的标志清除。<br>\n（4）剩余区：代码中的其余部分。</p>\n<p>为禁止两个进程同时进入临界区，同步机制应该遵循以下规则：<br>\n（1）空闲让进。<br>\n（2）忙则等待。<br>\n（3）有限等待。<br>\n（4）让权等待。</p>\n<h4 id=\"实现临界区互斥的基本方法\"><a class=\"anchor\" href=\"#实现临界区互斥的基本方法\">#</a> 实现临界区互斥的基本方法</h4>\n<h5 id=\"软件方法\"><a class=\"anchor\" href=\"#软件方法\">#</a> 软件方法</h5>\n<p>单标志检查法：只能交替进入，违背空闲让进</p>\n<p>双标志先检查法：可能同时进入临界区，违背忙则等待</p>\n<p>双标志后检查法：可能相互谦让，造成饥饿</p>\n<p>Peterson：未解决让权等待</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token comment\">//Pi 进程</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  \tflag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>true<span class=\"token punctuation\">;</span>turn<span class=\"token operator\">=</span>j<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">&amp;&amp;</span>turn<span class=\"token operator\">=</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>\t<span class=\"token comment\">// 临界区操作 j</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>\tflag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>false<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>\t<span class=\"token comment\">// 剩余区</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token comment\">//Pj 进程</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  \tflag<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>true<span class=\"token punctuation\">;</span>turn<span class=\"token operator\">=</span>i<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>\t<span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token operator\">&amp;&amp;</span>turn<span class=\"token operator\">=</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>\t<span class=\"token comment\">// 临界区操作</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>\tflag<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token operator\">=</span>false<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>\t<span class=\"token comment\">// 剩余区</span></pre></td></tr></table></figure><h5 id=\"硬件方式\"><a class=\"anchor\" href=\"#硬件方式\">#</a> 硬件方式</h5>\n<p>中断屏蔽</p>\n<p>TestAndSet 指令</p>\n<p>Swap 指令</p>\n<h5 id=\"信号量\"><a class=\"anchor\" href=\"#信号量\">#</a> 信号量</h5>\n<p>整形信号量</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>S<span class=\"token operator\">&lt;=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    S<span class=\"token operator\">=</span>S<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>记录信号量</p>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">wait</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">S</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    S<span class=\"token punctuation\">.</span>value<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">.</span>value<span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">// 注意 & lt;0</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>        S<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>P<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>        <span class=\"token function\">block</span><span class=\"token punctuation\">(</span>P<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 阻塞</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">struct</span> <span class=\"token class-name\">S</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span><span class=\"token comment\">// 注意 & lt;=0</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    S<span class=\"token punctuation\">.</span>value<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>S<span class=\"token punctuation\">.</span>value<span class=\"token operator\">&lt;=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        S<span class=\"token punctuation\">.</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>P<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        <span class=\"token function\">wakeup</span><span class=\"token punctuation\">(</span>P<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><h4 id=\"管程\"><a class=\"anchor\" href=\"#管程\">#</a> 管程</h4>\n<p>（1）管程的名称。<br>\n（2）局部于管程的共享结构数据说明。<br>\n（3）对该数据结构进行操作的一组过程 (函数)。<br>\n（4）对局部于管程内部的共享数据设置初始值的语句。</p>\n<p>管程把对共享资源的操作封装起来，管程内的共享数据结构只能被管程内的过程所访问。</p>\n<p>每次仅允许一个进程进入管程，从而实现进程互斥。</p>\n<h5 id=\"条件变量\"><a class=\"anchor\" href=\"#条件变量\">#</a> 条件变量</h5>\n<p>x.wait：当 x 对应的条件不满足时，正在调用管程的进程调用 x.wait 将自己插入到 x 条件的等待队列，并释放管程，此时其他进程可以使用该管程。<br>\nx.signal：x 对应的条件发生了变化，则调用 x.signal，唤醒了一个因 x 条件而阻塞的进程。<br>\n条件变量与信号量的比较：<br>\n相似点：条件变量的 wait/signal 操作类似于信号量的 P/V 操作，可以实现进程的阻塞和唤醒。<br>\n不同点：条件变量是 “没有值的”，仅实现了 “排队等待” 的功能；而信号量是 “有值的”，信号量反映了剩余资源的数目，而在管程中剩余资源数用共享数据结构记录。</p>\n<h4 id=\"经典同步问题\"><a class=\"anchor\" href=\"#经典同步问题\">#</a> 经典同步问题</h4>\n<h5 id=\"生产者与消费者模型\"><a class=\"anchor\" href=\"#生产者与消费者模型\">#</a> 生产者与消费者模型</h5>\n<p>注意 mutex 和 empty（或 full）的先后顺序，会造成死锁</p>\n<h5 id=\"读者与写者问题\"><a class=\"anchor\" href=\"#读者与写者问题\">#</a> 读者与写者问题</h5>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>semaphore rmutex <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> wmutex <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 互斥锁</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> readcount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">reader</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>     <span class=\"token keyword\">do</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>         <span class=\"token comment\">//P(w);</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>          <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>rmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 关锁</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>readcount <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token function\">wait</span><span class=\"token punctuation\">(</span>wmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 把写操作锁住，只需要在第一次读时</span></pre></td></tr><tr><td data-num=\"8\"></td><td><pre>          readcount<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 读者数目 + 1</span></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>          <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>rmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 开锁</span></pre></td></tr><tr><td data-num=\"10\"></td><td><pre>         <span class=\"token comment\">//V(w);</span></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>          <span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"12\"></td><td><pre></pre></td></tr><tr><td data-num=\"13\"></td><td><pre>          <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>rmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 关锁</span></pre></td></tr><tr><td data-num=\"14\"></td><td><pre>          readcount<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 读者数目 - 1</span></pre></td></tr><tr><td data-num=\"15\"></td><td><pre>          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>readcount <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token function\">V</span><span class=\"token punctuation\">(</span>wmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 没有读者，执行写操作</span></pre></td></tr><tr><td data-num=\"16\"></td><td><pre>          <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>rmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">// 开锁</span></pre></td></tr><tr><td data-num=\"17\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>TRUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"18\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr><tr><td data-num=\"19\"></td><td><pre><span class=\"token keyword\">void</span> <span class=\"token function\">writer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"20\"></td><td><pre>     <span class=\"token keyword\">do</span><span class=\"token punctuation\">&#123;</span></pre></td></tr><tr><td data-num=\"21\"></td><td><pre>         <span class=\"token comment\">//P(w);</span></pre></td></tr><tr><td data-num=\"22\"></td><td><pre>          <span class=\"token function\">P</span><span class=\"token punctuation\">(</span>rmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"23\"></td><td><pre>          <span class=\"token function\">write</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"24\"></td><td><pre>          <span class=\"token function\">V</span><span class=\"token punctuation\">(</span>rmutex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"25\"></td><td><pre>         <span class=\"token comment\">//V(w);</span></pre></td></tr><tr><td data-num=\"26\"></td><td><pre>     <span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>TRUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"27\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>会造成饥饿问题，加上注释部分可实现<strong>相对公平</strong></p>\n<h5 id=\"哲学家进餐问题\"><a class=\"anchor\" href=\"#哲学家进餐问题\">#</a> 哲学家进餐问题</h5>\n<p>会造成死锁</p>\n<p>解决方案：1. 同时拿起左右两根筷子</p>\n<p>2. 偶数哲学家先拿左筷子，奇数哲学家先拿右筷子</p>\n<p>3. 只允许 n-1 个人拿筷子</p>\n<h5 id=\"吸烟者问题\"><a class=\"anchor\" href=\"#吸烟者问题\">#</a> 吸烟者问题</h5>\n<p>将不同材料整合为一个材料的思想</p>\n<p>其他实现比较简单</p>\n<hr>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211107233843200.png\" alt=\"image-20211107233843200\"><span class=\"rainbow\"> 互斥信号量初值为 1</span></p>\n<p><span class=\"rainbow\">多个进程在任意时刻可共享的代码为可重入代码（纯码）（不可修改的代码）</span></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211107233806315.png\" alt=\"image-20211107233806315\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211107234055791.png\" alt=\"image-20211107234055791\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211107234025816.png\" alt=\"image-20211107234025816\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211107234208255.png\" alt=\"image-20211107234208255\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211107234235556.png\" alt=\"image-20211107234235556\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211107234257386.png\" alt=\"image-20211107234257386\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211107234316820.png\" alt=\"image-20211107234316820\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211107234336105.png\" alt=\"image-20211107234336105\"></p>\n<h2 id=\"死锁\"><a class=\"anchor\" href=\"#死锁\">#</a> 死锁</h2>\n<p>死锁产生的原因有：1. 系统资源的竞争。2. 进程推进顺序非法。<br>\n死锁产生的必要条件：1. 互斥条件：2. 不可剥夺条件 3. 请求并保持条件 4. 循环等待条件<br>\n::info</p>\n<p>死锁检测，死锁避免，死锁预防</p>\n<p>对死锁的处理从宽到严，并发性从大到小</p>\n<p>::</p>\n<h4 id=\"死锁预防\"><a class=\"anchor\" href=\"#死锁预防\">#</a> 死锁预防</h4>\n<h5 id=\"破坏互斥条件使临界资源共享不现实\"><a class=\"anchor\" href=\"#破坏互斥条件使临界资源共享不现实\">#</a> 破坏互斥条件 (使临界资源共享，不现实)</h5>\n<h5 id=\"破坏不剥夺条件\"><a class=\"anchor\" href=\"#破坏不剥夺条件\">#</a> 破坏不剥夺条件</h5>\n<p>实现比较复杂，反复剥夺会增加系统开销，降低系统吞吐量，适合 cpu，寄存器等容易回复的资源</p>\n<h5 id=\"破坏请求并保持条件\"><a class=\"anchor\" href=\"#破坏请求并保持条件\">#</a> 破坏请求并保持条件</h5>\n<p>采用预先静态分配方法，即进程在运行前就一次性申请完所有资源。<br>\n特点：实现简单，但是资源被严重浪费，甚至可能导致进程饥饿。</p>\n<h5 id=\"破坏循环等待条件\"><a class=\"anchor\" href=\"#破坏循环等待条件\">#</a> 破坏循环等待条件</h5>\n<p>采用顺序资源分配法，首先给系统资源进行编号，规定每个进程按照编号递增的顺序对资源进行申请，同类资源一次性申请完。</p>\n<p>当使用资源顺序和规定顺序不同，会造成浪费</p>\n<h4 id=\"死锁避免\"><a class=\"anchor\" href=\"#死锁避免\">#</a> 死锁避免</h4>\n<p><span class=\"rainbow\">并非所有不安全状态都为死锁状态</span></p>\n<h5 id=\"银行家算法\"><a class=\"anchor\" href=\"#银行家算法\">#</a> 银行家算法</h5>\n<p>要注意先判断<strong>所需资源数</strong>和<strong>申请资源数</strong></p>\n<p>还有<strong>安全性算法</strong></p>\n<h4 id=\"死锁检测和解除\"><a class=\"anchor\" href=\"#死锁检测和解除\">#</a> 死锁检测和解除</h4>\n<h5 id=\"资源分配图\"><a class=\"anchor\" href=\"#资源分配图\">#</a> 资源分配图</h5>\n<p>请求边，分配边</p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211108000010609.png\" alt=\"image-20211108000010609\"></p>\n<h5 id=\"死锁定理\"><a class=\"anchor\" href=\"#死锁定理\">#</a> 死锁定理</h5>\n<p>在资源分配图中找到分配满足的进程，然后消去其请求边与分配边，如果最后所有边都可以被消除，那么就是可以简化的，不存在死锁，否则存在死锁。</p>\n<h5 id=\"死锁解除\"><a class=\"anchor\" href=\"#死锁解除\">#</a> 死锁解除</h5>\n<p>资源剥夺法：挂起某些死锁进程，抢占资源，将这些资源分配给其他死锁进程，但是要防止挂起时间过长。<br>\n撤销进程法：强制撤销部分甚至全部死锁进程，并且剥夺他们的资源，撤销原则可以根据优先级和撤销进程的代价进行。<br>\n进程回退法：让一个或者多个进程回退到足以回避死锁的地步，进程回退时，自动释放资源而非剥夺，要求系统保持进程历史信息，设置还原点。</p>\n<hr>\n<p><span class=\"rainbow\">银行家算法不能检测死锁（哎）</span></p>\n<ol start=\"3\">\n<li class=\"quiz\">引入多道程序技术的前提之一是系统具有 {.gap} \n<ul class=\"options\">\n<li>多个 cpu</li>\n<li class=\"correct\">中断功能</li>\n<li>多个终端</li>\n<li>不分时功能</li>\n</ul>\n</li>\n</ol>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211108001058938.png\" alt=\"image-20211108001058938\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211108001112463.png\" alt=\"image-20211108001112463\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211108001501032.png\" alt=\"image-20211108001501032\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211108001524691.png\" alt=\"image-20211108001524691\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211108001542686.png\" alt=\"image-20211108001542686\"></p>\n",
            "tags": [
                "考研",
                "操作系统"
            ]
        },
        {
            "id": "http://example.com/2021/10/29/%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/",
            "url": "http://example.com/2021/10/29/%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/",
            "title": "统计量及其分布",
            "date_published": "2021-10-29T07:54:32.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "http://example.com/2021/10/11/%E7%9B%B8%E4%BC%BC%E7%90%86%E8%AE%BA/",
            "url": "http://example.com/2021/10/11/%E7%9B%B8%E4%BC%BC%E7%90%86%E8%AE%BA/",
            "title": "相似理论",
            "date_published": "2021-10-11T02:27:26.000Z",
            "content_html": "<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211014141754934.png\" alt=\"image-20211014141754934\"></p>\n<p><span class=\"rainbow\">P 相当于列操作，P 的逆相当于同等操作的行操作</span></p>\n<p><span class=\"rainbow\">一定要注意是不是单位向量</span></p>\n<p><span class=\"rainbow\">实对乘矩阵不同特征值的特征向量相互正交</span></p>\n<p><span class=\"rainbow\">如果一个矩阵的特征值没有 0，则这个矩阵可逆</span></p>\n<p><span class=\"rainbow\">相似必有相同的特征值，反之则不然，因为可能不能相似对角化</span></p>\n<p><img data-src=\"image-20211011105111165.png\" alt=\"image-20211011105111165\"></p>\n<p><img data-src=\"image-20211011105129684.png\" alt=\"image-20211011105129684\"></p>\n<p><span class=\"rainbow\">AP=PB，P 可逆，则 A,B 相似</span></p>\n<p>4 个性质</p>\n<p><img data-src=\"image-20211011203108513.png\" alt=\"image-20211011203108513\"></p>\n<p>正交化</p>\n<p><img data-src=\"image-20211011210843148.png\" alt=\"image-20211011210843148\"></p>\n<hr>\n<p><img data-src=\"image-20211011213003959.png\" alt=\"image-20211011213003959\"></p>\n<p><span class=\"rainbow\">任意实对称矩阵，都可由两个正交向量相乘的矩阵加上他的反制矩阵组成，所以必有特征值：k，-k，0</span></p>\n<p><img data-src=\"image-20211011213559807.png\" alt=\"image-20211011213559807\"></p>\n<p><img data-src=\"image-20211012095208574.png\" alt=\"image-20211012095208574\"></p>\n<p><span class=\"rainbow\">方程组也可以特征值来求</span></p>\n<p><img data-src=\"image-20211012150502145.png\" alt=\"image-20211012150502145\"></p>\n<p><img data-src=\"image-20211012150426162.png\" alt=\"image-20211012150426162\"></p>\n<hr>\n<p><img data-src=\"image-20211013110405267.png\" alt=\"image-20211013110405267\"></p>\n<p><img data-src=\"image-20211013110624690.png\" alt=\"image-20211013110624690\"></p>\n<p><img data-src=\"image-20211013110647808.png\" alt=\"image-20211013110647808\"></p>\n<p><img data-src=\"image-20211013110722470.png\" alt=\"image-20211013110722470\"></p>\n",
            "tags": [
                "考研",
                "线性代数"
            ]
        },
        {
            "id": "http://example.com/2021/09/26/%E8%A1%8C%E5%88%97%E5%BC%8F/",
            "url": "http://example.com/2021/09/26/%E8%A1%8C%E5%88%97%E5%BC%8F/",
            "title": "行列式",
            "date_published": "2021-09-26T02:42:42.000Z",
            "content_html": "<p><img data-src=\"image-20210926105834477.png\" alt=\"image-20210926105834477\"></p>\n<p><img data-src=\"image-20210926110021570.png\" alt=\" \"></p>\n<p><img data-src=\"image-20210926134342100.png\" alt=\"image-20210926134342100\"></p>\n<hr>\n<p><img data-src=\"image-20210926112731960.png\" alt=\"image-20210926112731960\"></p>\n<p><img data-src=\"image-20210926114959041.png\" alt=\"image-20210926114959041\"></p>\n<hr>\n<p><img data-src=\"image-20210926113931510.png\" alt=\"image-20210926113931510\"></p>\n<hr>\n<p><img data-src=\"image-20210926112742335.png\" alt=\"image-20210926112742335\"></p>\n<h2 id=\"抽象行列式的计算\"><a class=\"anchor\" href=\"#抽象行列式的计算\">#</a> 抽象行列式的计算</h2>\n<p><img data-src=\"image-20210926142715643.png\" alt=\"image-20210926142715643\"></p>\n<p>矩阵的性质，相似理论等</p>\n<hr>\n<p><span class=\"rainbow\">注意爪形的计算</span></p>\n<hr>\n<p><img data-src=\"image-20210926153823858.png\" alt=\"image-20210926153823858\"></p>\n<h2 id=\"代数余子式\"><a class=\"anchor\" href=\"#代数余子式\">#</a> 代数余子式</h2>\n<p>矩阵和特征值。。。</p>\n",
            "tags": [
                "考研",
                "线性代数"
            ]
        },
        {
            "id": "http://example.com/2021/09/26/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%BE%E5%BD%A2/",
            "url": "http://example.com/2021/09/26/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A9%BA%E9%97%B4%E5%9B%BE%E5%BD%A2/",
            "title": "几种常见的空间图形",
            "date_published": "2021-09-26T00:54:38.000Z",
            "content_html": "<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210926085928910.png\" alt=\"image-20210926085928910\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210926090536981.png\" alt=\"image-20210926090536981\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210926090607583.png\" alt=\"image-20210926090607583\"></p>\n",
            "tags": [
                "考研",
                "高等数学"
            ]
        },
        {
            "id": "http://example.com/2021/09/20/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/",
            "url": "http://example.com/2021/09/20/%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/",
            "title": "输入/输出系统",
            "date_published": "2021-09-20T15:03:36.000Z",
            "content_html": "<h3 id=\"磁盘存储器\"><a class=\"anchor\" href=\"#磁盘存储器\">#</a> 磁盘存储器</h3>\n<p>磁头数：记录面数</p>\n<p>柱面数：磁道数</p>\n<p>扇区数：磁盘读写的最小单位</p>\n<hr>\n<p>磁盘容量：非格式化容量：磁化单元总数，由道密度和位密度计算 --- 格式化容量：按照特定格式存储，容量比非格式化小</p>\n<p>记录密度：道密度，位密度，面密度 = 道密度 * 位密度</p>\n<p>平均存取时间：寻道时间，旋转延迟时间（旋转一周时间的一半），传输时间（扫过扇区的时间）</p>\n<p>数据传输率：=rN，设磁盘转速为 r 转 / 秒，每条磁道容量为 N 字节</p>\n<hr>\n<p>磁盘地址（驱动器号 -- 柱面 (磁道) 号 -- 盘面号 -- 扇区号）</p>\n<p><span class=\"rainbow\">汉字内码在主存中占 2B</span></p>\n<h2 id=\"io接口\"><a class=\"anchor\" href=\"#io接口\">#</a> I/O 接口</h2>\n<h5 id=\"io接口的功能\"><a class=\"anchor\" href=\"#io接口的功能\">#</a> I/O 接口的功能</h5>\n<p>进行地址译码和设备选择</p>\n<p>实现数据缓冲</p>\n<p>传送控制命令和状态信息</p>\n<p>信号格式的转换（主机与外设的电平，数据格式可能存在差异）</p>\n<h5 id=\"io接口的基本结构\"><a class=\"anchor\" href=\"#io接口的基本结构\">#</a> I/O 接口的基本结构</h5>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210921110825448.png\" alt=\"image-20210921110825448\"></p>\n<p>地址线：用以选择和主机交换信息的 ++ 寄存器 ++</p>\n<p>控制线：传送 读 / 写信号 ，此外还会传送仲裁信号，握手信号</p>\n<p>I/O 控制逻辑：对控制寄存器的命令字进行译码，并通过外设界面控制逻辑送到外设 ---- 同时将数据缓冲寄存器的数据发到外设，或者反过来</p>\n<hr>\n<p>对数据缓冲寄存器，状态 / 控制寄存器的访问操作通过 ++ I/O 指令 <ins>完成，只能在操作系统内核的底层 I/O 软件中使用，是</ins> 特权指令 ++</p>\n<h5 id=\"io接口的类型\"><a class=\"anchor\" href=\"#io接口的类型\">#</a> I/O 接口的类型</h5>\n<p>1. 按数据传送方式：并行接口（一个字节或字的所有位同时传输），串行接口</p>\n<p>（这里所说的数据传送方式指的是外设和接口一侧，主机和接口一侧数据总是并行传送）</p>\n<p>2. 按主机访问 I/O 设备的控制方式：程序查询接口，中断接口，DMA 接口</p>\n<p>3. 按功能的灵活性：可编程接口，不可</p>\n<h5 id=\"io端口及其编址\"><a class=\"anchor\" href=\"#io端口及其编址\">#</a> I/O 端口及其编址</h5>\n<p>数据端口，状态端口，控制端口，若干端口加上相应的控制逻辑电路组成接口（通常 CPU 能对数据端口进行读写，对状态端口只读，对控制端口只写）</p>\n<hr>\n<p>统一编址：存储器映射方式</p>\n<p>优点：不需要专门的输入输出指令，使 cpu 访问 I/O 操作更灵活，有较大的编址空间</p>\n<p>缺点：占用存储器空间</p>\n<p>独立编址：I/O 映射方式（要设置专门的 I/O 指令来访问 I/O 端口）</p>\n<p>优点：与存储器指令区分，程序编制清晰</p>\n<p>缺点：增加控制的复杂性</p>\n<ol start=\"3\">\n<li class=\"quiz\">I/O 总线的数据线上传送的信号包括<span class=\"gap\"></span> 。\n<ul class=\"options\">\n<li class=\"correct\">I/O 接口的命令字</li>\n<li class=\"correct\">I/O 接口的状态字</li>\n<li class=\"correct\">中断类型号</li>\n</ul>\n</li>\n</ol>\n<p><span class=\"rainbow\">磁盘驱动器向盘片磁道记录数据时采用串行方式写入</span></p>\n<p><span class=\"rainbow\">程序员进行系统调用访问设备使用 ++ 逻辑地址 ++</span></p>\n<h2 id=\"io方式\"><a class=\"anchor\" href=\"#io方式\">#</a> I/O 方式</h2>\n<h5 id=\"程序查询方式\"><a class=\"anchor\" href=\"#程序查询方式\">#</a> 程序查询方式</h5>\n<p>信息交换完全由主机执行程序实现</p>\n<p>程序查询接口中设置一个数据缓冲寄存器和一个设备状态寄存器</p>\n<h5 id=\"程序中断方式\"><a class=\"anchor\" href=\"#程序中断方式\">#</a> 程序中断方式</h5>\n<h6 id=\"异常cpu内部中断\"><a class=\"anchor\" href=\"#异常cpu内部中断\">#</a> 异常（cpu 内部中断）：</h6>\n<p>硬故障中断，程序性异常（软中断）</p>\n<p>按发生异常的报告方式和返回方式不同分为：</p>\n<p>1.== 故障 ==（指在引起故障等指令启动后，执行结束前背检测到的异常事件）</p>\n<p>有些可回到发生故障的指令后继续执行，有些不行</p>\n<p>2.== 自陷 ==（发生后 cpu 将机内操作系统内核程序执行）</p>\n<p>自动根据不同陷阱类型进行相应处理，然后返回下一条指令执行，当自陷指令是转移指令是，则</p>\n<ol start=\"3\">\n<li>== 终止 ==（在指令执行过程中发生了使计算机无法继续执行的硬件故障，如掉电）</li>\n</ol>\n<h6 id=\"外部中断狭义上称为中断\"><a class=\"anchor\" href=\"#外部中断狭义上称为中断\">#</a> 外部中断（狭义上称为中断）</h6>\n<p>I/O 中断（键盘输入，打印机缺纸），外部信号中断（用户按 Esc），各种定时器产生的时钟中断</p>\n<h6 id=\"中断的基本概念\"><a class=\"anchor\" href=\"#中断的基本概念\">#</a> 中断的基本概念</h6>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210921135656166.png\" alt=\"image-20210921135656166\"></p>\n<p><img data-src=\"C:%5CUsers%5Czz%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210921135635992.png\" alt=\"image-20210921135635992\"></p>\n<h6 id=\"程序中断的基本流程\"><a class=\"anchor\" href=\"#程序中断的基本流程\">#</a> 程序中断的基本流程</h6>\n<p>中断请求</p>\n<p>对每个中断源的请求设置中断请求标记触发器 INTR，这些触发器组成中断请求标记寄存器（可集中在 cpu，也可分散在各中断源）</p>\n<p>++ 内中断皆为不可屏蔽中断 ++</p>\n<p>++ 通过 INTR 信号线发出的外中断是可屏蔽信号，可被关中断（IF=1）影响</p>\n<p>NMI 信号线上的是不可屏蔽中断 ++</p>\n<hr>\n<p>中断判优</p>\n<p>硬件排队器，程序查询（软件实现）</p>\n<p><span class=\"rainbow\">硬件故障中断属于最高级，其次是软件中断，不可屏蔽中断优于可屏蔽中断，DMA 请求优于 I/O 设备传送的中断请求，高速设备优于低速设备，实时设备优于普通设备</span></p>\n<hr>\n<p>中断响应</p>\n<p>中断隐指令（硬件直接实现）</p>\n<p>​\t1. 关中断</p>\n<p>​\t2. 保存断点（PC,PSWR）</p>\n<p>​\t3. 引出中断服务程序</p>\n<hr>\n<p>中断向量</p>\n<p>cpu 响应中断后，中断硬件自动将中断向量地址传送到 cpu</p>\n<p>::info</p>\n<p>​\t中断向量是中断程序的入口地址，中断向量地址。。。</p>\n<p>::</p>\n<hr>\n<p>中断处理过程</p>\n<p>图片</p>\n<p>保存断点：可压入栈中也可存入主存的特定单元中</p>\n<p>引出中断服务程序：硬件向量法（硬件产出中断类型号（指出中断向量地址）），软件查询法</p>\n<p>保存现场和屏蔽字：现场信息指的是用户可见的工作寄存器的内容</p>\n<p>::info</p>\n<p>​\t现场信息保存由软件实现，断点信息保存由硬件实现</p>\n<p>::</p>\n<h6 id=\"多重中断和中断屏蔽技术\"><a class=\"anchor\" href=\"#多重中断和中断屏蔽技术\">#</a> 多重中断和中断屏蔽技术</h6>\n<h5 id=\"dma方式直接存储器存取方式\"><a class=\"anchor\" href=\"#dma方式直接存储器存取方式\">#</a> DMA 方式（直接存储器存取方式）</h5>\n<h6 id=\"dma控制器的组成\"><a class=\"anchor\" href=\"#dma控制器的组成\">#</a> DMA 控制器的组成</h6>\n<h6 id=\"dma传送方式\"><a class=\"anchor\" href=\"#dma传送方式\">#</a> DMA 传送方式</h6>\n<p>停止 cpu 访存，周期挪用（盗取），DMA 和 CPU 交替访存</p>\n<h6 id=\"dma传送过程\"><a class=\"anchor\" href=\"#dma传送过程\">#</a> DMA 传送过程</h6>\n<p>1. 预处理</p>\n<p>（可以说设备驱动程序）向 DMA 控制器的有关寄存器设置初值，设置传送方向，启动该设备</p>\n<p>2. 数据传送（完全由 DMA 实现）</p>\n<p>可以以单字节位基本单位，也可以以数据块位基本单位，DMA 占据总线后数据输入输出通过循环实现</p>\n<p>3. 后处理</p>\n<p>DMA 向 cpu 发送终端请求，cpu 执行中断服务程序（校验送入主存的数据是否正确，测试传送过程中是否出错。。。）</p>\n<h5 id=\"dma方式和中断方式的区别\"><a class=\"anchor\" href=\"#dma方式和中断方式的区别\">#</a> DMA 方式和中断方式的区别</h5>\n<p>DMA 请求的响应可以发生在每个机器周期结束（也可以说发生在总线周期结束，只要 cpu 不占总线资源）</p>\n<p>DMA 数据传输效率高，适合高速设备</p>\n<p>DMA 请求优先于中断请求</p>\n<p>中断方式具有对异常事件的处理能力，DMA 方式仅限于传送数据块的 I/O 操作</p>\n<p>从数据传输上看，中断方式靠程序传送，DMA 方式靠硬件传送</p>\n<ol start=\"3\">\n<li class=\"quiz\">\n<p>主存故障引起的中断是<span class=\"gap\"></span> 。</p>\n<ul class=\"options\">\n<li>I/O 中断</li>\n<li>程序性中断</li>\n<li>外中断</li>\n<li class=\"correct\">机器校验中断</li>\n</ul>\n</li>\n<li class=\"quiz\">\n<p>在配有通道的计算机系统中，用户程序需要输入输出时，引起的中断是<span class=\"gap\"></span> 。</p>\n<ul class=\"options\">\n<li>I/O 中断</li>\n<li>程序性中断</li>\n<li>外中断</li>\n<li class=\"correct\">访管中断</li>\n</ul>\n</li>\n<li class=\"quiz\">\n<p>设置中断屏蔽标志可以改变<span class=\"gap\"></span> 。</p>\n<ul class=\"options\">\n<li>多个中断源的中断请求优先级</li>\n<li>cpu 对多个中断请求响应的优先次序</li>\n<li>多个中断服务程序开始执行的顺序</li>\n<li class=\"correct\">多个中断服务程序执行完的次序</li>\n</ul>\n</li>\n<li class=\"quiz\">\n<p>在采用中断 I/O 方式控制打印输出的情况下，CPU 和打印控制接口中的 I/O 端口交换的信息不可能是<span class=\"gap\"></span> 。</p>\n<ul class=\"options\">\n<li>打印字符</li>\n<li>设备状态</li>\n<li>控制命令</li>\n<li class=\"correct\">主存地址</li>\n</ul>\n</li>\n</ol>\n<hr>\n<p><span class=\"rainbow\">MIPS = 指令执行速度</span></p>\n<p>第 8 题</p>\n<p>第 10 题有疑问</p>\n",
            "tags": [
                "考研",
                "计算机组成原理"
            ]
        },
        {
            "id": "http://example.com/2021/09/20/%E6%80%BB%E7%BA%BF/",
            "url": "http://example.com/2021/09/20/%E6%80%BB%E7%BA%BF/",
            "title": "总线",
            "date_published": "2021-09-20T15:02:58.000Z",
            "content_html": "<h2 id=\"总线概叙\"><a class=\"anchor\" href=\"#总线概叙\">#</a> 总线概叙</h2>\n<p>特点：分时，共享</p>\n<p>特性：机械特性，电气特性，功能特性，时间特性</p>\n<p>总线的猝发传送方式：在一个总线周期内传送地址连续的多个数据字</p>\n<p>总线分类：片选总线，系统总线，通信总线（外部总线）</p>\n<hr>\n<p>单总线</p>\n<p>双总线：主存总线，I/O 总线</p>\n<p>三总线：主存总线，I/O 总线，DMA（直接内存访问）总线</p>\n<hr>\n<p>总线周期：申请阶段，寻址阶段，传输阶段和结束阶段</p>\n<p>总线时钟周期 = 机器时钟周期</p>\n<p>总线工作频率：时钟频率 / N</p>\n<p>总线时钟频率</p>\n<p>信号线数：地址总线，数据总线，控制总线三种信号线的总和称为信号线数</p>\n<p><span class=\"rainbow\">并行总线传输比串行总线传输速度快</span></p>\n<ol start=\"3\">\n<li class=\"quiz\">下列关于多总线结构的叙述中错误的是<span class=\"gap\"></span> 。\n<ul class=\"options\">\n<li>靠近 cpu 的总线速度快</li>\n<li>存储器总线可支持突发传送方式</li>\n<li>总线之间通过桥接器相连</li>\n<li class=\"correct\">PCI-Express16 采用并行传输方式</li>\n<li><img data-src=\"$CABB%5BOFGCJ8$SUKJ%5D62K4V.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"总线事务和定时\"><a class=\"anchor\" href=\"#总线事务和定时\">#</a> 总线事务和定时</h2>\n<p>申请分配阶段：总线主模块提出申请，经总线仲裁机构将下一传输周期的总线使用权授予某一申请者</p>\n<p>寻址阶段：主模块通过总线发出本次要访问的从模块的地址及有关命令</p>\n<p>传输阶段：主模块和从模块进行数据交换 (单向或双向)</p>\n<p>结束阶段</p>\n<h5 id=\"同步定时方式\"><a class=\"anchor\" href=\"#同步定时方式\">#</a> 同步定时方式</h5>\n<p>采用统一时钟信号，在一个总线周期内，可以进行一次数据传送</p>\n<p>优点：传输速度快</p>\n<p>缺点：主从设备属于强制性同步，可靠性差</p>\n<h5 id=\"异步定时方式\"><a class=\"anchor\" href=\"#异步定时方式\">#</a> 异步定时方式</h5>\n<p>没有统一的时钟信号，通过握手信号实现定时控制</p>\n<p>不互锁方式：</p>\n<p>半互锁方式</p>\n<p>全互锁方式：主设备发出 “请求” 信号后，必须在从设备 “回答” 后才撤销 “请求” 信号；从设备发出 “回答” 信号后，必须在获知主设备 “请求” 信号已撤销后，再撤销其 “回答” 信号</p>\n<p><img data-src=\"image-20210921103739428.png\" alt=\"image-20210921103739428\"></p>\n",
            "tags": [
                "考研",
                "计算机组成原理"
            ]
        },
        {
            "id": "http://example.com/2021/09/20/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6%EF%BC%88%E4%BB%85%E6%95%B0%E4%B8%80%EF%BC%89/",
            "url": "http://example.com/2021/09/20/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6%EF%BC%88%E4%BB%85%E6%95%B0%E4%B8%80%EF%BC%89/",
            "title": "多元函数积分学（仅数一）",
            "date_published": "2021-09-20T05:47:48.000Z",
            "content_html": "<p><span class=\"rainbow\">要使用好对称性和轮转对称性</span></p>\n<h4 id=\"球面坐标系\"><a class=\"anchor\" href=\"#球面坐标系\">#</a> 球面坐标系</h4>\n<p><img data-src=\"image-20210920145254164.png\" alt=\"image-20210920145254164\"></p>\n<p><img data-src=\"image-20210922194113197.png\" alt=\"image-20210922194113197\"></p>\n<hr>\n<h2 id=\"第一型曲线积分\"><a class=\"anchor\" href=\"#第一型曲线积分\">#</a> 第一型曲线积分</h2>\n<p>有密度的曲线</p>\n<p><img data-src=\"image-20210922195230282.png\" alt=\"image-20210922195230282\"></p>\n<hr>\n<p><img data-src=\"image-20210922195644117.png\" alt=\"image-20210922195644117\"></p>\n<p><span class=\"rainbow\">遇到空间曲线，一般利用轮转对称性，对称性</span></p>\n<p><img data-src=\"image-20210922195811310.png\" alt=\"image-20210922195811310\"></p>\n<p><img data-src=\"image-20210922195825275.png\" alt=\"image-20210922195825275\"></p>\n<h2 id=\"第一型曲面积分\"><a class=\"anchor\" href=\"#第一型曲面积分\">#</a> 第一型曲面积分</h2>\n<p>带密度的曲面</p>\n<p><img data-src=\"image-20210922201858567.png\" alt=\"image-20210922201858567\"></p>\n<h2 id=\"第二型曲线积分\"><a class=\"anchor\" href=\"#第二型曲线积分\">#</a> 第二型曲线积分</h2>\n<p>做功</p>\n<p><img data-src=\"image-20210922204243613.png\" alt=\"image-20210922204243613\"></p>\n<p><img data-src=\"image-20210922204302544.png\" alt=\"image-20210922204302544\"></p>\n<p><span class=\"rainbow\">2，3 都是路径无关</span></p>\n<p><img data-src=\"image-20210923142155839.png\" alt=\"image-20210923142155839\"></p>\n<p><img data-src=\"image-20210923142210976.png\" alt=\"image-20210923142210976\"></p>\n<p><img data-src=\"image-20210923144555252.png\" alt=\"image-20210923144555252\"></p>\n<hr>\n<h4 id=\"摆线方程\"><a class=\"anchor\" href=\"#摆线方程\">#</a> 摆线方程</h4>\n<p><img data-src=\"image-20210923151541849.png\" alt=\"image-20210923151541849\"></p>\n<hr>\n<p><img data-src=\"image-20210923194637283.png\" alt=\"image-20210923194637283\"></p>\n<p><img data-src=\"image-20210923201337416.png\" alt=\"image-20210923201337416\"></p>\n<p>::info</p>\n<p>没有理解，henfan</p>\n<p>::</p>\n<p><img data-src=\"image-20210923203524556.png\" alt=\"image-20210923203524556\"></p>\n<p><img data-src=\"image-20210923204806560.png\" alt=\"image-20210923204806560\"></p>\n<hr>\n<p><img data-src=\"image-20210924092052207.png\" alt=\"image-20210924092052207\"></p>\n<hr>\n<p><img data-src=\"image-20210924143010687.png\" alt=\"image-20210924143010687\"></p>\n<hr>\n<p><img data-src=\"image-20210924154609155.png\" alt=\"image-20210924154609155\"></p>\n<hr>\n<p><img data-src=\"image-20210924161815314.png\" alt=\"image-20210924161815314\"></p>\n<p><img data-src=\"image-20210925210033435.png\" alt=\"image-20210925210033435\"></p>\n<hr>\n<h2 id=\"第2型曲面积分\"><a class=\"anchor\" href=\"#第2型曲面积分\">#</a> 第 2 型曲面积分</h2>\n<p><img data-src=\"image-20210924175335448.png\" alt=\"image-20210924175335448\"></p>\n<p><img data-src=\"image-20210924181502402.png\" alt=\"image-20210924181502402\"></p>\n<p><img data-src=\"image-20210924183301980.png\" alt=\"image-20210924183301980\"></p>\n<p><img data-src=\"image-20210925090027489.png\" alt=\"image-20210925090027489\"></p>\n<p><img data-src=\"image-20210925091034432.png\" alt=\"image-20210925091034432\"></p>\n<p><img data-src=\"image-20210925101735987.png\" alt=\"image-20210925101735987\"></p>\n<p><img data-src=\"image-20210925102715791.png\" alt=\"image-20210925102715791\"></p>\n<hr>\n<p><img data-src=\"image-20210925183232039.png\" alt=\"image-20210925183232039\"></p>\n<p><img data-src=\"image-20210925183255492.png\" alt=\"image-20210925183255492\"></p>\n<hr>\n<p><img data-src=\"image-20210925195126637.png\" alt=\"image-20210925195126637\"></p>\n<p><span class=\"rainbow\">转化为参数方程</span></p>\n<p><img data-src=\"image-20210925195158836.png\" alt=\"image-20210925195158836\"></p>\n<p><img data-src=\"image-20210925200545374.png\" alt=\"image-20210925200545374\"></p>\n",
            "tags": [
                "考研",
                "高等数学"
            ]
        }
    ]
}